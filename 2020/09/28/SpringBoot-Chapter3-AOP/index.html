<!DOCTYPE html>
<html lang="en">
<meta name="referrer" content="no-referrer"/>
<head>

<!-- 爆炸效果 -->
<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script type="text/javascript" src="/js/firework.js"></script>


  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"52zhongneng.cn","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Aop简介AOP的全称是Aspect Oriented Programming，翻译成中文是面向切面编程。它的主要思想是在程序正常执行的某一个点切进去加入特定的逻辑。AOP框架中对AOP支持最完整的是Aspectj，Spring Aop是基于Aspectj实现的专门针对于Spring自身支持的Aop，它的功能没有Aspectj那么完整，它只作用于Spring bean容器中bean对象的某个方法的">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot_Chapter3_AOP">
<meta property="og:url" content="https://52zhongneng.cn/2020/09/28/SpringBoot-Chapter3-AOP/index.html">
<meta property="og:site_name" content="Eloise&#39;s Paradise">
<meta property="og:description" content="Aop简介AOP的全称是Aspect Oriented Programming，翻译成中文是面向切面编程。它的主要思想是在程序正常执行的某一个点切进去加入特定的逻辑。AOP框架中对AOP支持最完整的是Aspectj，Spring Aop是基于Aspectj实现的专门针对于Spring自身支持的Aop，它的功能没有Aspectj那么完整，它只作用于Spring bean容器中bean对象的某个方法的">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-09-28T12:06:04.000Z">
<meta property="article:modified_time" content="2022-07-07T01:55:39.145Z">
<meta property="article:author" content="Brooks.H.Joshua">
<meta property="article:tag" content="Spring-Boot">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://52zhongneng.cn/2020/09/28/SpringBoot-Chapter3-AOP/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>SpringBoot_Chapter3_AOP | Eloise's Paradise</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div id="id-header-inner"  class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Eloise's Paradise</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags<span class="badge">34</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories<span class="badge">15</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives<span class="badge">79</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>
	<!-- 改变css样式 -->
<script type="text/javascript">
var url = document.location.pathname;
var folderName = url.substr(1, url.length - 2)
console.log(folderName);

var listPostUrl = [
    "/" + folderName + "/" + "post-banner.png",
    "/" + folderName + "/" + "post-banner.jpg",
];

var nSuccessCount = 0;
var nResponceCount = 0;
function OnHttpResponse(bSuccess, strUrl) {
    console.log("OnHttpResponse: " + bSuccess + ", " + strUrl);
    nResponceCount++;
    if(nSuccessCount > 0){
        return;
    }
    if(bSuccess) {
        nSuccessCount++;
        document.getElementById("id-header-inner").style.backgroundImage = "url(" + strUrl + ")";
    }
    if(nResponceCount >= listPostUrl.length && nSuccessCount <= 0){
        // 使用默认图
        document.getElementById("id-header-inner").style.backgroundImage = "url(/images/background.jpg)";
    }
}

function changeBanner(strPostUrl, nIndex){
    console.log("try to load" + strPostUrl);
    var xmlhttp;
    if (window.XMLHttpRequest)
    {
        //  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
        xmlhttp=new XMLHttpRequest();
    }
    else
    {
        // IE6, IE5 浏览器执行代码
        xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
    }
    xmlhttp.onreadystatechange=function()
    {
        if (xmlhttp.readyState==4 && xmlhttp.status==200)
        {
            OnHttpResponse(true, strPostUrl);
        } else {
            OnHttpResponse(false, strPostUrl);
        }
    }
    xmlhttp.open("HEAD",strPostUrl,true);
    xmlhttp.send();
}

listPostUrl.forEach(changeBanner);
</script>



    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://52zhongneng.cn/2020/09/28/SpringBoot-Chapter3-AOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Brooks.H.Joshua">
      <meta itemprop="description" content="Less Is More">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eloise's Paradise">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SpringBoot_Chapter3_AOP
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-28 20:06:04" itemprop="dateCreated datePublished" datetime="2020-09-28T20:06:04+08:00">2020-09-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-07 09:55:39" itemprop="dateModified" datetime="2022-07-07T09:55:39+08:00">2022-07-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Boot/" itemprop="url" rel="index">
                    <span itemprop="name">Spring-Boot</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>69k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1:02</span>
            </span>


           
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Aop简介"><a href="#Aop简介" class="headerlink" title="Aop简介"></a>Aop简介</h1><p>AOP的全称是Aspect Oriented Programming，翻译成中文是面向切面编程。它的主要思想是在程序正常执行的某一个点切进去加入特定的逻辑。AOP框架中对AOP支持最完整的是Aspectj，Spring Aop是基于Aspectj实现的专门针对于Spring自身支持的Aop，它的功能没有Aspectj那么完整，它只作用于Spring bean容器中bean对象的某个方法的执行。正如Spring官方文档所描述的那样，Spring Aop与Aspectj不是竞争关系，而是相互补充、相互完善的这么一个关系。</p>
<a id="more"></a>

<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>AOP框架的基本原理基本上都是通过代理的方式对目标对象达到切入式的切面编程的效果，Spring Aop也不例外。Spring Aop只能对它自身bean容器中定义的bean对象进行代理，这算是Spring Aop的一个限制，如果你的项目中不使用Spring的IOC，使用Spring的Aop显然是有点不那么合适的。Spring Aop中使用的代理有两种方式，一种是Jdk的动态代理，另一种是基于CGLIB实现的代理，当我们的bean对象实现了某一接口后，Spring默认将采用Jdk动态代理，当我们的bean对象没有实现接口时，默认将采用CGLIB代理，Spring也支持我们在bean对象实现了接口时也强制的使用CGLIB代理。Spring的Bean容器在初始化bean对象的时候就会判断对应的bean是否需要进行切面编程，即是否需要对其进行代理，如果需要，则初始化的时候就会把它初始化为一个代理对象。下面基于Jdk来看一个简单的示例，假设我们定义了如下这样一个代理工厂，其可以将一个普通的对象基于其实现的接口利用Jdk动态代理机制生成对应的代理对象。具体代码和说明请看如下代码，其中我们可以在目标对象执行特定的方法时加入一些特定的处理逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ProxyFactory instance = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">ProxyFactory</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProxyFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> T t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (T) Proxy.newProxyInstance(t.getClass().getClassLoader(), t.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 当使用创建的代理对象执行其中的方法时，都会转换为调用与代理对象绑定的InvocationHandler对象的invoke方法，</span></span><br><span class="line"><span class="comment">			 * 这样我们就可以在这个方法里面对调用情况进行一些特定的处理逻辑</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"正在调用的方法是："</span> + method);</span><br><span class="line">				<span class="comment">//1、加入对调用方法前的处理逻辑</span></span><br><span class="line">				<span class="comment">//...</span></span><br><span class="line">				Object result = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="comment">//2、正常的调用目标对象的目标方法</span></span><br><span class="line">					result = method.invoke(t, args);</span><br><span class="line">					<span class="comment">//3、可加入正常调用后的处理逻辑</span></span><br><span class="line">					<span class="comment">//...</span></span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="comment">//4、可加入目标对象的方法调用抛出异常后的处理逻辑</span></span><br><span class="line">					<span class="comment">//..</span></span><br><span class="line">				&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					<span class="comment">//5、可加入目标对象的方法执行完成后的处理逻辑，此逻辑不论是否抛出异常都将执行</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是基于上述代码进行的一个简单示例，具体如下，有兴趣的朋友也可以自己试一试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ProxyFactory proxyFactory = ProxyFactory.getInstance();</span><br><span class="line">	<span class="comment">//创建一个实现了UserService接口的对象</span></span><br><span class="line">	UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">	<span class="comment">//创建一个基于userService对象的代理对象</span></span><br><span class="line">	UserService proxy = proxyFactory.create(userService);</span><br><span class="line">	<span class="comment">//调用代理对象的某个方法</span></span><br><span class="line">	User user = proxy.findById(<span class="number">1</span>);</span><br><span class="line">	System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述只是一个简单的示例，只是为了说明Spring Aop的大体原理，实际上Spring Aop的代理逻辑比这个要复杂很多，在初始化bean后它需要判断该bean是否需要创建代理对象，这通常都是BeanPostProcessor的功能。有兴趣的读者可以参考一下DefaultListableBeanFactory的preInstantiateSingletons方法，了解一下Spring bean的初始化过程，更详细的内容请参考AbstractApplicationContext.refresh方法。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在了解Spring Aop的用法前，我们需要先了解一下Spring Aop中的一些重要概念，这些概念的英文名称摘自Spring的官方文档，这些术语在本系列文章中出现时可能会以原始英文的形式出现。</p>
<ul>
<li>Aspect：切面类，是面向切面编程的主体类，用以定义Pointcut和Advice这样的对应关系。</li>
<li>Join Point：切入点，程序运行的某一个点，比如执行某个方法，在Spring AOP中Join Point总是表示一个方法的执行。</li>
<li>Advice：切面类Aspect需要在Join Point处执行的操作。Advice的类型主要包括Before、After和Around三种。包括Spring在类的很多AOP框架都会把Advice以类似于Interceptor（拦截器）的形式进行封装，然后在每个Join Point的前后都可以包含一个Interceptor链，即可以进行多个操作处理。</li>
<li>Pointcut：用来定义匹配的Join Point的，它是一个表达式。它往往会跟Advice绑定在一起，用以指定需要在Pointcut表达式匹配的Join Point执行的操作。采用Pointcut表达式来匹配Join Point是AOP中一个非常重要的概念，它能够使得我们的Advice能够比较独立，即一个Advice可以同时服务于多个JoinPoint。Spring AOP默认采用Aspectj（AOP的始祖）的Pointcut表达式。</li>
<li>Introduction：用来声明额外的方法和属性。可以给目标对象引入新的接口及其实现。例如可以使用Introduction让一个bean实现isModified接口。</li>
<li>Target Object：目标对象，表示Aspect正在处理的对象。因为Spring AOP是基于运行时代理实现的，所以这个对象永远都是一个代理对象。</li>
<li>Aop Proxy：由AOP框架创建的一个代理对象。在Spring AOP中这个代理对象将由JDK代理（基于接口）或CGLIB代理（基于Class）生成。</li>
<li>Weaving：表示编织的意思。用以将切面类Aspect与目标对象联系在一起的这么一个动作，所形成的结果就是在Pointcut所指定的Join Point执行时由Aspect对目标对象执行特定的Advice。AOP框架中的Weaving动作可以发生在编译时、类装载时和运行时，Spring AOP的Weaving动作是发生在运行时。</li>
</ul>
<h3 id="Advice类型"><a href="#Advice类型" class="headerlink" title="Advice类型"></a>Advice类型</h3><p>Advice的类型主要有Before、After和Around三种，Before作用于JoinPoint执行前，After作用于JoinPoint执行后（After类型还可以细分），Around则可作用于JoinPoint执行前后，且JoinPoint的执行需要在Around类型的Advice中进行调用，具体如下：</p>
<ul>
<li>Before：Before类型的Advice将在Join Point执行前运行，除非在运行时抛出一个异常，否则Before类型的Advice不会阻止Join Point的运行。</li>
<li>After Return：After Return类型的Advice将在Join Point正常执行完成（return）后运行，即Join Point的运行没有抛出对外的异常后返回的。</li>
<li>After Throwing：After Throwing类型的Advice将在Join Point抛出对外的异常后运行。</li>
<li>After （finally）：After类型的Advice不论Join Point的执行结果如何都将运行。</li>
<li>Around：Around类型的Advice将围绕一个Join Point执行，它既可以在Join Point执行前执行特定的逻辑，也可以在Join Point执行后执行特定的逻辑，还可以控制Join Point是否执行、抛出异常、修改返回值等。</li>
</ul>
<p>Around Advice的功能是最强大的，所有其它Advice能够满足的需求使用Around Advice也都能够满足。但是Spring官方并推荐我们大量的使用Around Advice，而是使用最简单最能满足我们需要的那个Advice。比如如果你只是想简单的在Join Point执行完成后根据返回值来更新缓存，那你使用After Return Advice将比使用Around Advice更合适。这不但能够使你的程序更加的简单，也能减少你出错的机会（使用Around Advice时需要用户自己调用JoinPoint的proceed方法，让JoinPoint继续运行），更能减少程序运行的复杂度。</p>
<p>Spring AOP目前只支持对方法执行这样的JoinPoint进行特定的Advice处理，更确切的来说是只支持对Spring Bean容器里面的bean定义的方法执行进行切入特定的处理逻辑。如果你需要对属性的访问也进行拦截，也执行特定的Advice，那么你可以考虑使用Aspectj。还有一点需要注意的是切面类不会被自动代理，不能作为其它切面类作用的目标类，即使你配置的Poincut目标对象能包含对应的Aspect也不行。</p>
<p>（注：本文是基于Spring4.1.0所写）</p>
<h1 id="基于Aspectj注解的Spring-Aop简单实现"><a href="#基于Aspectj注解的Spring-Aop简单实现" class="headerlink" title="基于Aspectj注解的Spring Aop简单实现"></a>基于Aspectj注解的Spring Aop简单实现</h1><p>Spring Aop是基于Aop框架Aspectj实现的，它不是完完全全的对Aspectj框架进行扩展和改造，而是利用Aspectj里面的一些功能来实现自己的Aop框架，其中就包括对Aspectj提供的注解的解析。之前已经提过Spring Aop和Aspectj实现的Aop之间的差别，这里就不再赘述。本文主要描述的是如何利用Aspectj提供的注解来实现Spring Aop功能，旨在让大家对Spring Aop、对使用Aspectj注解开发Spring Aop有一个初步印象。</p>
<h2 id="启用对Aspectj注解的支持"><a href="#启用对Aspectj注解的支持" class="headerlink" title="启用对Aspectj注解的支持"></a>启用对Aspectj注解的支持</h2><p>使用Aspectj注解来实现Spring Aop时我们首先需要启用Spring对Aspectj注解支持的功能，这是通过配置来进行的。当我们的Spring配置是以配置文件为主时，我们可以通过在Spring的配置文件中引入aop相关的schema，然后通过``来启用对Aspectj注解的支持。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.elim.test"</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 启用对Aspectj注解的支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当我们的配置是通过使用@Configuration标注的配置类来进行的时候，我们就可以通过在该配置类上使用@EnableAspectJAutoProxy进行标注来启用对Aspectj注解的支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义切面类"><a href="#定义切面类" class="headerlink" title="定义切面类"></a>定义切面类</h2><p>定义切面类比较简单，只需要定义一个简单的使用@Aspect进行标注的类即可。@Aspect是Spring Aop识别切面类的一个标记，但是光使用@Aspect对切面类进行标注还不行。因为Spring Aop只能对定义在bean容器中的bean发生作用，对应的切面类也必须是定义在bean容器中的bean对象时其才能发现。@Aspect不具备默认让Spring扫描到它，把对应的类实例化为Spring bean的功能，所以我们必须要在bean容器中定义该bean。可以通过配置文件定义，也可以通过使用@Component进行标注等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@Aspect标注的切面类也可以像普通类一样定义普通的属性和方法，如果有需要也可以把它当做一个普通的bean使用。</p>
<h2 id="定义Pointcut"><a href="#定义Pointcut" class="headerlink" title="定义Pointcut"></a>定义Pointcut</h2><p>Pointcut是用来定义切面类需要作用的JoinPoint的，在Spring Aop中这些JoinPoint其实就是一些我们需要进行切入的方法执行，因为之前我们说过Spring Aop只支持对bean方法执行的切入。基于Aspect注解形式定义的Pointcut的核心是@Pointcut注解，我们需要在Aspect类中定义一个没有返回值的方法，方法类型可任意，然后在该方法上使用@Pointcut进行标注，表示其是一个Pointcut定义，对应的方法名即表示该Pointcut的名称。@Pointcut有一个value属性，其通常是一个表达式，通过它可以指定当前Pointcut需要作用的JoinPoint。表达式可以有很多种写法，这个在后续会专门讲解，通常用的最多的就是execution，表示方法的执行。如我们想定义一个Pointcut的JoinPoint为所有add方法的执行，那么我们可以如下定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Pointcut</span>(<span class="string">"execution(* add(..))"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义Advice"><a href="#定义Advice" class="headerlink" title="定义Advice"></a>定义Advice</h2><p>Advice需要与Pointcut绑定在一起，用以定义需要在指定的Pointcut匹配的JoinPoint处执行的操作。Advice主要有三种类型，before、after和around，Aspectj对它们都有对应的注解进行支持。基于Aspectj注解的advice定义是通过对应的注解来指定的，我们需要在切面类中定义一个方法，然后在该方法上使用对应的注解进行标注。对应的advice注解都有一个value属性，我们需要通过它来指定与之绑定的Pointcut，对应的Pointcut需要通过Pointcut定义的类全名称.方法名()来指定，如果是在当前切面类中定义的Pointcut则可以省略对应的类名称。这里主要拿before来做一个示例，如下，我们在切面类中定义了一个方法before，并用@Before注解标注了该方法，同时指定了其所绑定的Pointcut为同一个切面类中定义的pointcut。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Pointcut</span>(<span class="string">"execution(* add(..))"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Before</span>(<span class="string">"com.elim.test.spring.aop.MyAspect.pointcut()"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">		System.out.println(joinPoint.getTarget() + <span class="string">"----------------------Before---------------------"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，当我们在访问Spring bean容器中任意bean对象的add方法前就会调用MyAspect切面类中定义的before方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@ContextConfiguration("classpath:applicationContext.xml")</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserService userService;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		User user = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"ZhangSan"</span>);</span><br><span class="line">		userService.add(user);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Pointcut表达式介绍"><a href="#Pointcut表达式介绍" class="headerlink" title="Pointcut表达式介绍"></a>Pointcut表达式介绍</h1><h2 id="表达式类型"><a href="#表达式类型" class="headerlink" title="表达式类型"></a>表达式类型</h2><p>标准的Aspectj Aop的pointcut的表达式类型是很丰富的，但是Spring Aop只支持其中的9种，外加Spring Aop自己扩充的一种一共是10种类型的表达式，分别如下。</p>
<ul>
<li>execution：一般用于指定方法的执行，用的最多。</li>
<li>within：指定某些类型的全部方法执行，也可用来指定一个包。</li>
<li>this：Spring Aop是基于代理的，生成的bean也是一个代理对象，this就是这个代理对象，当这个对象可以转换为指定的类型时，对应的切入点就是它了，Spring Aop将生效。</li>
<li>target：当被代理的对象可以转换为指定的类型时，对应的切入点就是它了，Spring Aop将生效。</li>
<li>args：当执行的方法的参数是指定类型时生效。</li>
<li>@target：当代理的目标对象上拥有指定的注解时生效。</li>
<li>@args：当执行的方法参数类型上拥有指定的注解时生效。</li>
<li>@within：与@target类似，看官方文档和网上的说法都是@within只需要目标对象的类或者父类上有指定的注解，则@within会生效，而@target则是必须是目标对象的类上有指定的注解。而根据笔者的测试这两者都是只要目标类或父类上有指定的注解即可。</li>
<li>@annotation：当执行的方法上拥有指定的注解时生效。</li>
<li>bean：当调用的方法是指定的bean的方法时生效。</li>
</ul>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="execution"><a href="#execution" class="headerlink" title="execution"></a>execution</h3><p>execution是使用的最多的一种Pointcut表达式，表示某个方法的执行，其标准语法如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? </span><br><span class="line">	name-pattern(param-pattern) <span class="keyword">throws</span>-pattern?)</span><br></pre></td></tr></table></figure>

<p>modifiers-pattern表示方法的访问类型，public等；ret-type-pattern表示方法的返回值类型，如String表示返回类型是String，“<em>”表示所有的返回类型；declaring-type-pattern表示方法的声明类，如“com.elim..<em>”表示com.elim包及其子包下面的所有类型；name-pattern表示方法的名称，如“add</em>”表示所有以add开头的方法名；param-pattern表示方法参数的类型，name-pattern(param-pattern)其实是一起的表示的方法集对应的参数类型，如“add()”表示不带参数的add方法，“add(</em>)”表示带一个任意类型的参数的add方法，“add(*,String)”则表示带两个参数，且第二个参数是String类型的add方法；throws-pattern表示异常类型；其中以问号结束的部分都是可以省略的。</p>
<ul>
<li>1、“execution(* add())”匹配所有的不带参数的add()方法。</li>
<li>2、“execution(public * com.elim..<em>.add</em>(..))”匹配所有com.elim包及其子包下所有类的以add开头的所有public方法。</li>
<li>3、“execution(* *(..) throws Exception)”匹配所有抛出Exception的方法。</li>
</ul>
<h3 id="within"><a href="#within" class="headerlink" title="within"></a>within</h3><p>within是用来指定类型的，指定类型中的所有方法将被拦截。</p>
<ul>
<li>1、“within(com.elim.spring.aop.service.UserServiceImpl)”匹配UserServiceImpl类对应对象的所有方法外部调用，而且这个对象只能是UserServiceImpl类型，不能是其子类型。</li>
<li>2、“within(com.elim..*)”匹配com.elim包及其子包下面所有的类的所有方法的外部调用。</li>
</ul>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>Spring Aop是基于代理的，this就表示代理对象。this类型的Pointcut表达式的语法是this(type)，当生成的代理对象可以转换为type指定的类型时则表示匹配。基于JDK接口的代理和基于CGLIB的代理生成的代理对象是不一样的。</p>
<ul>
<li>1、“this(com.elim.spring.aop.service.IUserService)”匹配生成的代理对象是IUserService类型的所有方法的外部调用。</li>
</ul>
<h3 id="target"><a href="#target" class="headerlink" title="target"></a>target</h3><p>Spring Aop是基于代理的，target则表示被代理的目标对象。当被代理的目标对象可以被转换为指定的类型时则表示匹配。</p>
<ul>
<li>1、“target(com.elim.spring.aop.service.IUserService)”则匹配所有被代理的目标对象能够转换为IUserService类型的所有方法的外部调用。</li>
</ul>
<h3 id="args"><a href="#args" class="headerlink" title="args"></a>args</h3><p>args用来匹配方法参数的。</p>
<ul>
<li>1、“args()”匹配任何不带参数的方法。</li>
<li>2、“args(java.lang.String)”匹配任何只带一个参数，而且这个参数的类型是String的方法。</li>
<li>3、“args(..)”带任意参数的方法。</li>
<li>4、“args(java.lang.String,..)”匹配带任意个参数，但是第一个参数的类型是String的方法。</li>
<li>5、“args(..,java.lang.String)”匹配带任意个参数，但是最后一个参数的类型是String的方法。</li>
</ul>
<h3 id="target-1"><a href="#target-1" class="headerlink" title="@target"></a>@target</h3><p>@target匹配当被代理的目标对象对应的类型及其父类型上拥有指定的注解时。</p>
<ul>
<li>1、“@target(com.elim.spring.support.MyAnnotation)”匹配被代理的目标对象对应的类型上拥有MyAnnotation注解时。</li>
</ul>
<h3 id="args-1"><a href="#args-1" class="headerlink" title="@args"></a>@args</h3><p>@args匹配被调用的方法上含有参数，且对应的参数类型上拥有指定的注解的情况。</p>
<ul>
<li>1、“@args(com.elim.spring.support.MyAnnotation)”匹配方法参数类型上拥有MyAnnotation注解的方法调用。如我们有一个方法add(MyParam param)接收一个MyParam类型的参数，而MyParam这个类是拥有注解MyAnnotation的，则它可以被Pointcut表达式“@args(com.elim.spring.support.MyAnnotation)”匹配上。</li>
</ul>
<h3 id="within-1"><a href="#within-1" class="headerlink" title="@within"></a>@within</h3><p>@within用于匹配被代理的目标对象对应的类型或其父类型拥有指定的注解的情况，但只有在调用拥有指定注解的类上的方法时才匹配。</p>
<ul>
<li>1、“@within(com.elim.spring.support.MyAnnotation)”匹配被调用的方法声明的类上拥有MyAnnotation注解的情况。比如有一个ClassA上使用了注解MyAnnotation标注，并且定义了一个方法a()，那么在调用ClassA.a()方法时将匹配该Pointcut；如果有一个ClassB上没有MyAnnotation注解，但是它继承自ClassA，同时它上面定义了一个方法b()，那么在调用ClassB().b()方法时不会匹配该Pointcut，但是在调用ClassB().a()时将匹配该方法调用，因为a()是定义在父类型ClassA上的，且ClassA上使用了MyAnnotation注解。但是如果子类ClassB覆写了父类ClassA的a()方法，则调用ClassB.a()方法时也不匹配该Pointcut。</li>
</ul>
<h3 id="annotation"><a href="#annotation" class="headerlink" title="@annotation"></a>@annotation</h3><p>@annotation用于匹配方法上拥有指定注解的情况。</p>
<ul>
<li>1、“@annotation(com.elim.spring.support.MyAnnotation)”匹配所有的方法上拥有MyAnnotation注解的方法外部调用。</li>
</ul>
<h3 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h3><p>bean用于匹配当调用的是指定的Spring的某个bean的方法时。</p>
<ul>
<li>1、“bean(abc)”匹配Spring Bean容器中id或name为abc的bean的方法调用。</li>
<li>2、“bean(user*)”匹配所有id或name为以user开头的bean的方法调用。</li>
</ul>
<h2 id="表达式组合"><a href="#表达式组合" class="headerlink" title="表达式组合"></a>表达式组合</h2><p>表达式的组合其实就是对应的表达式的逻辑运算，与、或、非。可以通过它们把多个表达式组合在一起。</p>
<ul>
<li>1、“bean(userService) &amp;&amp; args()”匹配id或name为userService的bean的所有无参方法。</li>
<li>2、“bean(userService) || @annotation(MyAnnotation)”匹配id或name为userService的bean的方法调用，或者是方法上使用了MyAnnotation注解的方法调用。</li>
<li>3、“bean(userService) &amp;&amp; !args()”匹配id或name为userService的bean的所有有参方法调用。</li>
</ul>
<h2 id="基于Aspectj注解的Pointcut表达式应用"><a href="#基于Aspectj注解的Pointcut表达式应用" class="headerlink" title="基于Aspectj注解的Pointcut表达式应用"></a>基于Aspectj注解的Pointcut表达式应用</h2><p>在使用基于Aspectj注解的Spring Aop时，我们可以把通过@Pointcut注解定义Pointcut，指定其表达式，然后在需要使用Pointcut表达式的时候直接指定Pointcut。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Pointcut</span>(<span class="string">"execution(* add(..))"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beforeAdd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Before</span>(<span class="string">"beforeAdd()"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"-----------before-----------"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们就是在@Before()中直接指定使用当前类定义的beforeAdd()方法对应的Pointcut的表达式，如果我们需要指定的Pointcut定义不是在当前类中的，我们需要加上类名称，如下面这个示例中引用的就是定义在MyService中的add()方法上的Pointcut的表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"com.elim.spring.aop.service.MyService.add()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"-----------before2-----------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然了，除了通过引用Pointcut定义间接的引用其对应的Pointcut表达式外，我们也可以直接使用Pointcut表达式的，如下面这个示例就直接在@Before中使用了Pointcut表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有的add方法的外部执行时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(* add())"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeExecution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"-------------before execution---------------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（注：本文是基于Spring4.1.0所写，写于2017年1月14日星期六）</p>
<h1 id="基于Aspectj注解的Advice介绍"><a href="#基于Aspectj注解的Advice介绍" class="headerlink" title="基于Aspectj注解的Advice介绍"></a>基于Aspectj注解的Advice介绍</h1><p>之前介绍过，Advice一共有五种类型，分别是before、after return、after throwing、after（finally）和around。在使用注解的时候，它们对应的注解分别是@Before、@AfterReturning、@AfterThrowing、@After和@Around。 这几个注解都是在org.aspectj.lang.annotation包中。</p>
<h2 id="Before"><a href="#Before" class="headerlink" title="@Before"></a>@Before</h2><p>Before Advice将在目标方法执行前执行Advice逻辑，通过它我们可以在指定的切入点方法执行前加入特定的逻辑。如下是定义的一个Before Advice，通过其value属性（注解中只指定value属性时属性名是可以省略的）指定其需要拦截的切入点id或name为userService的bean的方法执行，然后拦截后我们只是简单的打印一条语句，在实际应用中这里应该加上我们特定的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"bean(userService)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"-----before with pointcut expression: bean(userService)------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>1、@Before除了可以通过value属性指定需要拦截的切入点外，还可以指定一个argNames属性，这个是用于方便我们在Advice中访问切入点方法参数的，这个在后续会专门用一篇文章来讲如何在Advice中使用切入点方法参数。</li>
<li>2、argNames这个属性不仅在@Before上有，在其它的Advice注解上也有。</li>
<li>3、除非抛出异常，否则Before Advice是没法阻止程序继续往下执行的。</li>
</ul>
<p>所有的Advice方法都可以接收一个JoinPoint参数，而且这个参数必须是Advice方法的第一个参数，通过这个参数我们可以获取到目标方法的一些信息，比如当前方法调用传递的参数信息、目标对象等。而如果是Around类型的Advice则必须接受一个ProceedingJoinPoint类型的参数，ProceedingJoinPoint是JoinPoint的子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"bean(userService)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"-----before with pointcut expression: bean(userService)------"</span>);</span><br><span class="line">	joinPoint.getArgs();<span class="comment">//获取当前目标方法调用传递的参数</span></span><br><span class="line">	joinPoint.getSignature();<span class="comment">//获取当前目标方法的签名，通过它可以获取到目标方法名</span></span><br><span class="line">	joinPoint.getThis();<span class="comment">//获取AOP生成的代理对象</span></span><br><span class="line">	joinPoint.getTarget();<span class="comment">//获取被代理对象，即目标对象</span></span><br><span class="line">	System.out.println(joinPoint.getArgs());</span><br><span class="line">	System.out.println(joinPoint.getSignature().getName());</span><br><span class="line">	System.out.println(joinPoint.getThis().getClass());</span><br><span class="line">	System.out.println(joinPoint.getTarget().getClass());</span><br><span class="line">	System.out.println(joinPoint.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AfterReturning"><a href="#AfterReturning" class="headerlink" title="@AfterReturning"></a>@AfterReturning</h2><p>AfterReturning Advice对应的是切入点方法正常执行完的拦截，即切入点方法执行时没有对外抛出异常，包括在目标方法被Around类型的Advice处理时没有抛出异常，如果目标方法在被Around类型的Advice处理时也抛出了异常，则同样会被认为目标方法是执行异常的，因为Around Advice是最先处理的，AfterReturning Advice会在Around Advice处理结束后才被触发的。如果我们希望在AfterReturning Advice中根据目标方法的返回结果做特定的业务逻辑，那么我们可以给AfterReturning Advice处理方法加一个参数，参数类型可以是你能确定的目标方法返回类型或用通用的Object，然后需要在@AfterReturning上通过returning属性指定目标方法的返回值需要赋值给AfterReturning Advice处理方法的哪个参数。如下示例中就在Advice处理方法上加入了一个通用类型的Object类型的returnValue参数，然后指定@AfterReturning的returning属性为“returnValue”。如果我们确定目标方法的返回结果一定是一个User类型的，那么我们也可以指定下面的方法参数类型是User类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning</span>(value=<span class="string">"bean(userService)"</span>, returning=<span class="string">"returnValue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"-----after returning with pointcut expression: bean(userService)------"</span>);</span><br><span class="line">	System.out.println(<span class="string">"-----return value is: "</span> + returnValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AfterThrowing"><a href="#AfterThrowing" class="headerlink" title="@AfterThrowing"></a>@AfterThrowing</h2><p>AfterThrowing Advice对应的是切入点方法执行对外抛出异常的拦截。因为当一个切入点方法可以同时被Around Advice和AfterThrowing Advice拦截时，实际上AfterThrowing Advice拦截的是Around Advice处理后的结果，所以这种情况下最终AfterThrowing Advice是否能被触发，还要看Around Advice自身是否对外抛出异常，即算是目标方法对外抛出了异常，但是被Around Advice处理了又没有向外抛出异常的时候AfterThrowing Advice也不会被触发的。如果希望在AfterThrowing Advice处理方法中获取到被抛出的异常，可以给对应的Advice处理方法加一个Exception或其子类型（能确定抛出的异常类型）的方法参数，然后通过@AfterThrowing的throwing属性指定拦截到的异常对象对应的Advice处理方法的哪个参数。如下就指定了拦截到的异常对象将传递给Advice处理方法的ex参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span>(value=<span class="string">"bean(userService)"</span>, throwing=<span class="string">"ex"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"-----after throwing with pointcut expression: bean(userService)------"</span> + ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AfterThrowing是用于在切入点方法抛出异常时进行某些特殊的处理，但是它不会阻止方法调用者看到异常结果。</p>
<h2 id="After"><a href="#After" class="headerlink" title="@After"></a>@After</h2><p>After Advice就相当于try…catch…finally语句里面的finally的角色，即无论被拦截的切入点方法是成功执行完成还是对外抛出了异常，对应的Advice处理方法都将会执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After</span>(<span class="string">"bean(userService)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"-----after with pointcut expression: bean(userService)------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Around"><a href="#Around" class="headerlink" title="@Around"></a>@Around</h2><p>Around Advice必须接收一个ProceedingJoinPoint类型的方法参数，然后在方法体中选择一个合适的时机来调用ProceedingJoinPoint的proceed方法以触发对目标方法的调用，然后Around Advice处理方法的返回值会被当做是目标方法调用的返回值。所以通过Around Advice我们可以在通过ProceedingJoinPoint调用目标方法的前后加上特定的逻辑，包括使用try…catch…finally等，所以Around Advice是功能最强大的一个Advice，前面的任何一种Advice在应用的时候都可以被Around Advice替换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"bean(userService)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"-----around with pointcut expression: bean(userService)------"</span>);</span><br><span class="line">	System.out.println(<span class="string">"---------------------调用前---------------------"</span>);</span><br><span class="line">	Object result = pjp.proceed();</span><br><span class="line">	System.out.println(<span class="string">"---------------------调用后---------------------"</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中我们就通过Around Advice拦截了id或name为userService的bean的所有方法调用，把真实的目标方法的返回结果返回去了。而实际上我们这里还可以修改目标方法的返回结果，比如常用的就是Spring的缓存会通过Around Advice在调用目标方法前先从缓存中获取结果，如果获取到了则直接返回。这也是Around Advice跟AfterReturning Advice一个比较大的差别，AfterReturning Advice是不能改变返回对象的引用的，但是它可以改变返回对象的个别属性。在使用Around Advice时也可以改变目标方法调用时传递的参数，这个时候要用到ProceedingJoinPoint 的带参数的proceed(Object[] args)方法了。如下示例中我们就在Around Advice中把调用目标方法的参数替换为15了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"bean(userService)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"-----around with pointcut expression: bean(userService)------"</span>);</span><br><span class="line">	System.out.println(<span class="string">"---------------------调用前---------------------"</span>);</span><br><span class="line">	Object[] params = <span class="keyword">new</span> Object[]&#123;<span class="number">15</span>&#125;;</span><br><span class="line">	Object result = pjp.proceed(params);<span class="comment">//可以调整目标方法调用时传递的参数</span></span><br><span class="line">	System.out.println(<span class="string">"---------------------调用后---------------------"</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Advice执行顺序"><a href="#Advice执行顺序" class="headerlink" title="Advice执行顺序"></a>Advice执行顺序</h2><p>官方的说法是在进入切入点前优先级越高的越先执行，而在从切入点出去时优先级越高的会越后执行。当一个切面类中定义了多个Advice需要作用于同一个切入点时它们的执行顺序是不确定的，理由是无法通过反射获取到这些Advice在编译好的字节码中的声明顺序，这种情况下官方建议将多种切面逻辑整合到一个Advice中处理，以免造成错误。当两个定义在不同的切面中的Advice需要作用在同一个切入点时，除非你在切面类上使用@Order注解指定了顺序，数字越小表示优先级越高，或者是使切面类实现Ordered接口。以下是官方原文地址。</p>
<p><a href="http://docs.spring.io/spring/docs/4.1.0.RELEASE/spring-framework-reference/html/aop.html#aop-ataspectj-advice-ordering" target="_blank" rel="noopener">官网文档</a></p>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.9.RELEASE/spring-framework-reference/core.html#aop-introduction-defn" target="_blank" rel="noopener">新版地址5.2.9</a></p>
<p>（注：本文是基于Spring4.1.0所写，写于2017年1月19日星期四）</p>
<h1 id="给Advice传递参数"><a href="#给Advice传递参数" class="headerlink" title="给Advice传递参数"></a>给Advice传递参数</h1><p>Advice除了可以接收JoinPoint（非Around Advice）或ProceedingJoinPoint（Around Advice）参数外，还可以直接接收与切入点方法执行有关的对象，比如切入点方法参数、切入点目标对象（target）、切入点代理对象（this）等。</p>
<h2 id="获取切入点方法参数"><a href="#获取切入点方法参数" class="headerlink" title="获取切入点方法参数"></a>获取切入点方法参数</h2><p>假设我们现在有一个id为userService的bean中定义了一个findById(int id)方法，我们希望定义一个Advice来拦截这个方法，并且把findById()的参数作为Advice处理方法的参数，即每次调用findById()传递的参数都将传递到Advice处理方法，那么我们可以如下这样定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value=<span class="string">"bean(userService) &amp;&amp; execution(* findById(java.lang.Integer)) &amp;&amp; args(id)"</span>, argNames=<span class="string">"id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeWithParam</span><span class="params">(JoinPoint joinPoint, Integer id)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">" ID is : "</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种定义是非常精确的定义，我们通过表达式“bean(userService) &amp;&amp; execution(* findById(java.lang.Integer))”就已经明确的指定了我们需要拦截的是id或name为userService的findById(Integer)方法，后面又加了一个args(id)是干什么用的呢？它的作用跟findById(Integer)是类似的，它表示我们的切入点方法必须只接收一个参数，而且这个参数的类型是和当前定义的Advice处理方法的参数id是相同类型的，在上面的示例中其实就是要求是Integer类型的；另外它还有一个非常重要的作用，通过这种指定后对应的Advice处理方法在执行时将接收到与之对应的切入点方法参数的值。在上面的示例中笔者特意给Advice处理方法加了一个JoinPoint参数是为了说明JoinPoint、ProceedingJoinPoint参数是可以直接定义在Advice方法的第一个参数，并且是可以与其它接收的参数共存的。其实如果我们不只是需要拦截findById(Integer)方法，而是需要拦截id为userService的bean中所有接收一个int/Integer参数的方法，那么我们可以把上面的配置简化为如下这样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value=<span class="string">"bean(userService) &amp;&amp; args(id)"</span>, argNames=<span class="string">"id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeWithParam2</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">" ID is : "</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们需要拦截的方法可能是有多个参数的，但我们只关注第一个参数，那我们可以把表达式调整为如下这样，只关注第一个参数为int/Integer类型的，并且在Advice方法中接收这个方法参数进行相应的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value=<span class="string">"bean(userService) &amp;&amp; args(id,..)"</span>, argNames=<span class="string">"id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeWithParam2</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">" ID is : "</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="argNames参数"><a href="#argNames参数" class="headerlink" title="argNames参数"></a>argNames参数</h2><p>我们可以看到在上述例子中我们都指定了@Before的argNames属性的值为id，那么这个argNames属性有什么作用呢？argNames属性是用于指定在表达式中应用的参数名与Advice方法参数是如何对应的，argNames中指定的参数名必须与表达式中的一致，可以与Advice方法参数名不一致；当表达式中使用了多个参数时，argNames中需要指定多个参数，多个参数之间以英文逗号分隔，这些参数的顺序必须与对应的Advice方法定义的参数顺序是一致的。比如下面这个示例中，我们在Pointcut表达式中使用了name和sex两个参数，我们的Advice处理方法接收两个参数，分别是sex1和name1，我们希望Pointcut表达式中的name参数是对应的Advice处理方法的第二个参数，即name1，希望Pointcut表达式中的sex参数是对应的Advice处理方法的第一个参数，即sex1，那么我们在指定@Before注解的argNames参数时必须定义name和sex参数与Advice处理方法参数的关系，且顺序要求与对应的处理方法的参数顺序一致，即哪个参数是需要与Advice处理方法的第一个参数匹配则把哪个参数放第一位，与第二个参数匹配的则放第二位，在我们的这个示例中就应该是sex放第一位，name放第二位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value=<span class="string">"bean(userService) &amp;&amp; args(name, sex)"</span>, argNames=<span class="string">"sex, name"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeWithParam3</span><span class="params">(<span class="keyword">int</span> sex1, String name1)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"sex is : "</span> + sex1);</span><br><span class="line">	System.out.println(<span class="string">"name is : "</span> + name1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Before注解的argNames参数不是必须的，它只有在我们编译的字节码中不含DEBUG信息或Pointcut表达式中使用的参数名与Advice处理方法的参数名不一致时才需要。所以在编译的字节码中包含DEBUG信息且Advice参数名与Pointcut表达式中使用的参数名一致时，我们完全可以把argNames参数省略。如果表达式里面使用了多个参数，那么这些参数在表达式中的顺序可以与Advice方法对应参数的顺序不一致，例如下面这个样子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value=<span class="string">"bean(userService) &amp;&amp; args(id)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeWithParam2</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">" ID is : "</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取this对象"><a href="#获取this对象" class="headerlink" title="获取this对象"></a>获取this对象</h2><p>this对象就是Spring生成的bean的那个代理对象。如下示例就是Advice方法接收this对象，我们给Advice方法指定一个需要拦截的this对象类型的参数，然后在表达式中使用this类型的表达式定义，表达式中定义的对应类型指定为Advice方法参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"this(userService)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeWithParam4</span><span class="params">(IUserService userService)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//this对象应该是一个代理对象</span></span><br><span class="line">	System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">"==============传递this对象： "</span> + userService.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="混合使用"><a href="#混合使用" class="headerlink" title="混合使用"></a>混合使用</h2><p>我们的Advice方法可以同时接收多个目标方法参数，与此同时它也可以接收this等对象，即它们是可以混合使用的。下面这个示例中我们就同时接收了this对象和目标方法int/Interger类型的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"this(userService) &amp;&amp; args(id)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeWithParam5</span><span class="params">(IUserService userService, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">"==========="</span> + id + <span class="string">"=============="</span> + userService.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取target对象"><a href="#获取target对象" class="headerlink" title="获取target对象"></a>获取target对象</h2><p>获取target对象也比较简单，只需要把表达式改为target类型的表达式即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"target(userService)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeWithParam6</span><span class="params">(IUserService userService)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">"==============传递target对象： "</span> + userService.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取注解对象"><a href="#获取注解对象" class="headerlink" title="获取注解对象"></a>获取注解对象</h2><p>当我们的Pointcut表达式类型是通过注解匹配时，我们也可以在Advice处理方法中获取匹配的注解对象，如下面这个示例，其它如使用@target等是类似的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"@annotation(annotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeWithParam7</span><span class="params">(MyAnnotation annotation)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="keyword">this</span>.getClass().getName()+<span class="string">"==============传递标注在方法上的annotation： "</span> + annotation.annotationType().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型参数"><a href="#泛型参数" class="headerlink" title="泛型参数"></a>泛型参数</h2><p>有的时候我们的Advice方法需要接收的切入点方法参数定义的不是具体的类型，而是一个泛型，这种情况下怎么办呢？可能你会想那我就把对应的Advice方法参数定义为Object类型就好了，反正所有的类型都可以转换为Object类型。对的，这样是没有错的，但是说如果你只想拦截某种具体类型的参数调用时就可以不用把Advice方法参数类型定义为Object了，这样还得在方法体里面进行判断，我们可以直接把Advice方法参数类型定义为我们想拦截的方法参数类型。比如我们有下面这样一个使用了泛型的方法定义，我们希望只有在调用testParam方法时传递的参数类型是Integer类型时才进行拦截。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">testParam</span><span class="params">(T param)</span></span>;</span><br></pre></td></tr></table></figure>

<p>那这个时候我们就可以把我们的Advice的表达式定义为如下这样，前者精确定义接收方法名为testParam，返回类型为void，后者精确定义方法参数为一个Integer类型的参数，其实前者也可以定义为“execution(void testParam(Integer))”。看到这你可能会想，为什么不直接把表达式定义为“execution(void testParam(param))”呢？因为execution是不支持Advice方法参数绑定的，基本上支持Advice参数绑定的就只有this、target、args以及对应的注解形式加@annotation。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(void testParam(..)) &amp;&amp; args(param)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeWithParam8</span><span class="params">(Integer param)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"pointcut expression[args(param)]--------------param:"</span> + param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是常用的传递参数给Advice处理方法的方式，有一些示例可能没有讲到，比如@target这种，这些其实都是类似的。包括上面我们都是以@Before这种Advice来讲的，其实其它的Advice在接收参数的时候也是类似的。</p>
<p><strong>参考文档</strong><br>1、官方文档</p>
<p>（注：本文是基于Spring4.1.0所写，写于2017年1月20日星期五）</p>
<h1 id="DeclareParents介绍"><a href="#DeclareParents介绍" class="headerlink" title="@DeclareParents介绍"></a>@DeclareParents介绍</h1><p>@DeclareParents注解也是Aspectj提供的，在使用基于Aspectj注解的Spring Aop时，我们可以在切面中通过@DeclareParents指定满足指定表达式的类将自动实现某些接口。这个只是在运行时会将生成的代理类实现指定的接口。有接口就会有实现，对应的实现类也需要我们在@DeclareParents声明自动实现的接口时声明。现假设我们有一个接口叫CommonParent，其实现类叫CommonParentImpl，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonParent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonParentImpl</span> <span class="keyword">implements</span> <span class="title">CommonParent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"-----------do something------------"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们希望我们的所有的Service实现类都可以在运行时自动实现CommonParent接口，即所有的Service实现类在运行时都可以被当做CommonParent来使用。那我们可以定义如下这样一个切面类和对应的Advice。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeclareParentsAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@DeclareParents</span>(value=<span class="string">"com.elim.spring.aop.service..*"</span>, defaultImpl=CommonParentImpl<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	<span class="title">private</span> <span class="title">CommonParent</span> <span class="title">commonParent</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Before</span>(<span class="string">"bean(userService) &amp;&amp; this(commonParent)"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeUserService</span><span class="params">(CommonParent commonParent)</span> </span>&#123;</span><br><span class="line">		commonParent.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，我们先在切面类中声明了一个CommonParent类型的属性，然后在上面使用了@DeclareParents注解表示我们需要把CommonParent声明为某些指定类型的父接口，然后通过@DeclareParents的value属性指定需要作用的类的形式，其语法和Pointcut表达式类似。通过defaultImpl属性指定默认CommonParent接口的实现类是CommonParentImpl。然后我们声明了一个before类型的Advice，在其中直接把我们的bean当做CommonParent类型的对象使用。</p>
<p>整个过程就是这样的，非常简单。但是笔者暂时还没有发现这个在实际应用中可以应用于哪些场景，欢迎交流。</p>
<p>参考文档 1、官方文档</p>
<p>（注：本文是基于Spring4.1.0所写，写于2017年1月22日星期日）</p>
<h1 id="基于XML配置的Spring-AOP"><a href="#基于XML配置的Spring-AOP" class="headerlink" title="基于XML配置的Spring AOP"></a>基于XML配置的Spring AOP</h1><p>基于XML配置的Spring AOP需要引入AOP配置的Schema，然后我们就可以使用AOP Schema下定义的config、aspect、pointcut等标签进行Spring AOP配置了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/beans/spring-beans-4.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/context/spring-context-4.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.1.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基于XML配置的Spring AOP的核心配置是config元素，其它的诸如切面配置、切入点配置等都是配置在它的下面的，所以我们需要先定义一个config元素。</p>
<h2 id="配置切面"><a href="#配置切面" class="headerlink" title="配置切面"></a>配置切面</h2><p>切面的配置是通过aspect元素配置的，我们需要通过其ref属性指定切面类对应的Spring bean的id或name，还可以通过其order属性指定切面类的在拦截的时候的优先级。需要说明的是在使用Spring时基于XML的配置和基于注解的配置往往是可以混用的，所以在下面示例中我们使用的切面类引用不一定非得在Spring的bean配置文件中进行配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"schemaBasedAspect"</span> <span class="attr">class</span>=<span class="string">"com.elim.spring.aop.aspect.SchemaBasedAspect"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 基于XML的AOP配置是基于config元素开始的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 定义切面 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"aspect1"</span> <span class="attr">ref</span>=<span class="string">"schemaBasedAspect"</span> <span class="attr">order</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置切入点"><a href="#配置切入点" class="headerlink" title="配置切入点"></a>配置切入点</h2><p>切入点可以是直接配置在config元素下的，意为顶级切入点，也可以是配置在指定的aspect下面的。切入点的配置是通过pointcut元素来配置的，在配置的时候我们需要指定id和expression属性，expression属性就对应的是切入点的表达式，其配置规则跟基于Aspectj注解配置时的规则是一样的。如下示例中就定义了两个pointcut，一个是顶级的，一个是在aspectj1中定义的。需要注意的是顶级的Pointcut必须定义在aspect之前。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"bean(userService)"</span> <span class="attr">id</span>=<span class="string">"userServicePointCut2"</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 定义切面 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"aspect1"</span> <span class="attr">ref</span>=<span class="string">"schemaBasedAspect"</span> <span class="attr">order</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"bean(userService)"</span> <span class="attr">id</span>=<span class="string">"userServicePointCut"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果我们的切入点是以Aspectj注解的形式定义在类里面的，我们也可以像在前面介绍的基于Aspectj注解配置那样进行引用，如在下面这个配置就是使用的在SchemaBasedAspect类的pointcut方法上通过@Pointcut指定的表达式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"com.elim.spring.aop.aspect.SchemaBasedAspect.pointcut()"</span> <span class="attr">id</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置Advice"><a href="#配置Advice" class="headerlink" title="配置Advice"></a>配置Advice</h2><p>切面的最终目的是为了拦截指定切入点的方法执行，然后加入自己特定逻辑的，有了切面定义和切入点的定义后，我们需要定义在哪些切入点上需要使用切面的哪些Advice，即执行切面类的哪些方法。我们知道Advice有before、after、after returning、after throwing和around五种，对应的分别是before、after、after-returning、after-throwing和around标签，它们都是定义在aspect标签下的。这五类Advice在定义时的用法基本上是类似的，通过method方法指定Advice对应的是aspect类的哪个方法，然后通过pointcut指定切入点的表达式，或者通过pointcut-ref指定需要引用的是哪个切入点。如下示例中我们就定义了两个Advice，before Advice指定了对应的是切面类的doBefore方法，然后通过pointcut-ref指定需要使用的切入点是id为userServicePointCut的切入点；around Advice指定了对应的是切面类的doAround方法，然后通过pointcut直接指定了需要作用的切入点表达式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"aspect1"</span> <span class="attr">ref</span>=<span class="string">"schemaBasedAspect"</span> <span class="attr">order</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 定义一个Around Advice --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"doBefore"</span> <span class="attr">pointcut-ref</span>=<span class="string">"userServicePointCut"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"doAround"</span> <span class="attr">pointcut</span>=<span class="string">"bean(userService)"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"bean(userService)"</span> <span class="attr">id</span>=<span class="string">"userServicePointCut"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>和基于注解的配置类似，如果我们需要在afterReturning Advice中访问返回值，我们也可以给对应的处理方法一个返回值对应类型（或Object类型）的参数，然后通过after-returning元素的returning属性指定返回值需要赋予给Advice处理方法的哪个参数，参数名需要一致。同样afterThrowing类型的Advice需要在处理方法中接收抛出的异常时，也可以给定对应的处理方法一个Exception类型的参数，然后通过after-throwing元素的throwing属性指定抛出的异常需要赋值给Advice处理方法的哪个参数。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"doAfterReturning"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> <span class="attr">returning</span>=<span class="string">"returnValue"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"doAfterThrowing"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> <span class="attr">throwing</span>=<span class="string">"ex"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>参数传递也是类似的，在Advice处理方法上给定指定的参数，然后在定义Pointcut表达式的时候加上对应的参数传递限制，如“args(id)”、“this(userService)”等，在需要指定参数的绑定顺序时，可以通过before、around等Advice标签的arg-names属性指定。如下示例中我们就要求id为userServicePointCut的Pointcut需要接收一个参数，这个参数是需要跟对应的Advice处理方法绑定的，而before Advice是使用该Pointcut的，所以就要求id与对应的处理方法参数绑定，而且对应的方法参数名需要是id。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"aspect1"</span> <span class="attr">ref</span>=<span class="string">"schemaBasedAspect"</span> <span class="attr">order</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"doBefore"</span> <span class="attr">pointcut-ref</span>=<span class="string">"userServicePointCut"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"doAround"</span> <span class="attr">pointcut</span>=<span class="string">"bean(userService)"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"bean(userService) <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> args(id)"</span> <span class="attr">id</span>=<span class="string">"userServicePointCut"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们对应的doBefore处理方法是这样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"======================doBefore======================"</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中在定义id为userServicePointcut的表达式的时候用到了“&amp;&amp;”，这是因为在XML中&amp;是特殊字符，我们必须对它进行转义。其实在XML中配置Pointcut表达式时我们可以使用“and”、“or”和“not”替代“&amp;&amp;”、“||”和“!”。</p>
<h2 id="declare-parents"><a href="#declare-parents" class="headerlink" title="declare-parents"></a>declare-parents</h2><p>在基于注解的形式定义AOP时，我们有一个<code>@DeclareParents</code>注解可以给所有匹配的bean生成的代理默认加上指定的接口实现，并使用默认的实现。如果是基于XML配置时想达到对应的效果我们可以通过<code>declare-parents</code>元素。示例如下:</p>
<p>切面类<code>SchemaBasedAspect</code>有一个<code>doBefore</code>方法接收一个<code>CommonParent</code>参数，我们在配置切面时配置了一个<code>before Advice</code>将调用切面类的<code>doBefore</code>方法；通过<code>declare-parents</code>元素指定<code>service</code>包下面所有的类都实现<code>CommonParent</code>接口，底层在调用的时候将会调用<code>CommonParentImpl</code>的实现。<code>CommonParent</code>接口的源码没有提供，其只定义了一个返回类型为void的doSomething()方法。然后我们的before Advice将拦截id为<code>userService</code>的bean的所有方法调用，注意因为我们声明了所有的Service都将实现<code>CommonParent</code>接口，所以生成的id为<code>userService</code>的bean其实也是实现了<code>CommonParent</code>接口的，在调用的<code>doBefore</code>方法时传递的就是id为<code>userService</code>的bean，我们在<code>doBefore</code>方法中又继续调用<code>CommonParent</code>的<code>doSomething</code>方法就相当于重新调用了id为<code>userService</code>的bean的方法，会造成<code>before Advice</code>循环拦截和调用。</p>
<p>很显然此种情况下，我们是不希望CommonParent的方法调用还被拦截的，所以我们在对应的Pointcut表达式上把CommonParent的doSomething方法排除了。在应用注解的时候不用排除也不会循环调用，但是使用XML配置时必须排除。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(CommonParent commonParent)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"======================doBefore======================"</span>);</span><br><span class="line">	commonParent.doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&lt;bean id=<span class="string">"schemaBasedAspect"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.elim.spring.aop.aspect.SchemaBasedAspect"</span> /&gt;</span><br><span class="line">&lt;bean id=<span class="string">"commonParent"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.elim.spring.aop.service.CommonParentImpl"</span> /&gt;</span><br><span class="line">&lt;!-- 基于XML的AOP配置是基于config元素开始的 --&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">	&lt;aop:aspect id=<span class="string">"aspect1"</span> ref=<span class="string">"schemaBasedAspect"</span> order=<span class="string">"1"</span>&gt;</span><br><span class="line">		&lt;aop:before method=<span class="string">"doBefore"</span> pointcut-ref=<span class="string">"userServicePointCut"</span> /&gt;</span><br><span class="line">		&lt;aop:pointcut expression=<span class="string">"bean(userService) and this(commonParent) and !execution(void com.elim.spring.aop.service.CommonParent.doSomething())"</span></span><br><span class="line">			id=<span class="string">"userServicePointCut"</span> /&gt;</span><br><span class="line">		&lt;!-- 加上通用的父类 --&gt;</span><br><span class="line">		&lt;aop:declare-parents types-matching=<span class="string">"com.elim.spring.aop.service..*"</span></span><br><span class="line">			implement-<span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.elim.spring.aop.service.CommonParent"</span></span><br><span class="line">			delegate-ref=<span class="string">"commonParent"</span>/&gt;</span><br><span class="line">	&lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>

<h2 id="启用CGLIB代理类"><a href="#启用CGLIB代理类" class="headerlink" title="启用CGLIB代理类"></a>启用CGLIB代理类</h2><p>默认情况下当bean实现了接口时Spring AOP是基于JDK的动态代理的，也就是说我们生成的bean只能调用接口中定义的方法，如果我们的bean是没有实现接口的，则会采用CGLIB代理。如果我们希望不管bean是否实现了接口都采用CGLIB代理，则在基于Aspectj注解进行AOP配置时，我们可以通过aspectj-autoproxy元素的proxy-target-class=”true”启用CGLIB代理。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果是基于XML的配置时，我们也希望强制使用CGLIB代理时怎么办呢？我们可以在config元素上配置proxy-target-class=”true”。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（注：本文是基于Spring4.1.0所写，Elim写于2017年1月23日星期一）</p>
<h1 id="advisor标签"><a href="#advisor标签" class="headerlink" title="advisor标签"></a>advisor标签</h1><p>advisor标签是需要定义在aspect标签里面的，其作用与aspect类似，可以简单的把它理解为一个特殊的切面，用于把一个Advice和一个Pointcut组合起来。一个advisor标签对应的就是一个Advisor接口的实现类，默认是DefaultBeanFactoryPointcutAdvisor实现。其使用的基本语法类似如下这样。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">""</span> <span class="attr">pointcut-ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的advice-ref属性用于指定一个org.aopalliance.aop.Advice实现，该接口没有任何内容，只是起到标记作用，用于标记某个类是Advice。pointcut-ref用于指定一个通过已经存在的Pointcut定义，当然也可以直接通过pointcut属性指定对应的Pointcut表达式。如果在一个config元素下既定义了aspect，又定义了advisor，那advisor必须定义在aspect之前。接下来看一下如何通过advisor标签应用常用的5种Advice，本文旨在介绍advisor是如何用的，以及如何使用5种Advice，至于每种Advice的功能、区别啥的已经在之前的文章中已经介绍过了，就不再赘述了，有兴趣的读者请参考以前的博文。</p>
<h2 id="before-Advice"><a href="#before-Advice" class="headerlink" title="before Advice"></a>before Advice</h2><p>对应于切入点方法执行前的拦截的Advice接口是BeforeAdvice接口，这个接口也是一个空接口没有实现，我们在自定义自己的BeforeAdvice实现时不直接实现BeforeAdvice接口，而是实现MethodBeforeAdvice接口。这是Spring为了将来可以支持对类的成员变量的访问进行拦截而预留的定义，也就是说将来BeforeAdvice还会有一个基于对类的成员变量访问的拦截的子接口定义。MethodBeforeAdvice接口中定义了一个before方法，在调入目标方法前就会调用before方法。如下就是一个MethodBeforeAdvice的实现示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogBeforeAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"===============before advice start=============="</span>);</span><br><span class="line">		System.out.println(<span class="string">"method: "</span> + method);</span><br><span class="line">		System.out.println(<span class="string">"args: "</span> + args);</span><br><span class="line">		System.out.println(<span class="string">"target: "</span> + target);</span><br><span class="line">		System.out.println(<span class="string">"===============before advice end================"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了Advice之后，我们就可以通过advisor标签来把它和指定的PointCut绑定了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"bean(userService)"</span> <span class="attr">id</span>=<span class="string">"userServicePointcut"</span>/&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"logBeforeAdvice"</span> <span class="attr">order</span>=<span class="string">"1"</span> <span class="attr">pointcut-ref</span>=<span class="string">"userServicePointcut"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logBeforeAdvice"</span> <span class="attr">class</span>=<span class="string">"com.elim.spring.aop.advice.LogBeforeAdvice"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="around-Advice"><a href="#around-Advice" class="headerlink" title="around Advice"></a>around Advice</h2><p>around Advice的实现需要实现org.aopalliance.intercept.MethodInterceptor接口，该接口定义了一个接收MethodInvacation类型的参数的invoke方法。通过MethodInvocation对象可以获取到目标方法、方法参数等信息，然后还可以通过调用其proceed方法来调用对应的目标方法，所以我们可以根据需要来判断是否需要调用目标方法。invoke方法的返回值将作为目标方法的调用者接收到的返回值，所以我们也可以在invoke方法中根据需要判断需要给目标方法调用者返回什么样的结果。以下是一个MethodInterceptor接口实现示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAroundAdvice</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"=============================方法调用开始==="</span> + invocation.getMethod());</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Object result = invocation.proceed();</span><br><span class="line">			System.out.println(<span class="string">"=============================方法调用正常结束==="</span> + invocation.getMethod());</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"=============================方法调用异常==="</span> + invocation.getMethod());</span><br><span class="line">			<span class="keyword">throw</span> e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前介绍基于XML配置和基于Aspectj注解的配置进行Around Advice配置时都可以在运行时根据条件来改变实际调用目标方法时传递的参数，那么如果我们直接实现MethodInterceptor接口是否又可以呢？答案是肯定的，MethodInterceptor的invoke方法参数MethodInvocation中已经封装了或者目标方法和参数的信息，如果需要改变传递的参数，我们可以不调用MethodInvocation的proceed方法，而是选择获取当前Method，然后直接调用Method的invoke方法传递自己所需要的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAroundAdvice</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"=============================方法调用开始==="</span> + invocation.getMethod());</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Object result = invocation.getMethod().invoke(invocation.getThis(), <span class="number">1</span>);</span><br><span class="line">			System.out.println(<span class="string">"=============================方法调用正常结束==="</span> + invocation.getMethod());</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"=============================方法调用异常==="</span> + invocation.getMethod());</span><br><span class="line">			<span class="keyword">throw</span> e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其配置与before advice的配置是类似的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"bean(userService)"</span> <span class="attr">id</span>=<span class="string">"userServicePointcut"</span>/&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"logAroundAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"userServicePointcut"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logAroundAdvice"</span> <span class="attr">class</span>=<span class="string">"com.elim.spring.aop.advice.LogAroundAdvice"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="afterReturning-Advice"><a href="#afterReturning-Advice" class="headerlink" title="afterReturning Advice"></a>afterReturning Advice</h2><p>AfterReturning Advice将在目标方法正常返回时触发，对应的是AfterReturningAdvice接口，其定义如下，第一个参数是目标方法的返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AfterReturningAdvice</span> <span class="keyword">extends</span> <span class="title">AfterAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是笔者的一个测试实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAfterReturningAdvice</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"==============调用成功返回，返回值是："</span> + returnValue);</span><br><span class="line">		System.out.println(<span class="string">"Method: "</span> + method);</span><br><span class="line">		<span class="keyword">if</span> (returnValue <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">			<span class="comment">//不能修改返回值，但可以修改返回值的某些属性，因为是对象引用</span></span><br><span class="line">			((User) returnValue).setName(<span class="string">"modifyedName"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="afterThrowing-Advice"><a href="#afterThrowing-Advice" class="headerlink" title="afterThrowing Advice"></a>afterThrowing Advice</h2><p>afterThrowing Advice对应的Advice接口子类是ThrowsAdvice，该接口也是一个空接口，也是用于标记作用的，但是不同于BeforeAdvice定义了可供用户实现的包含方法定义的子接口MethodBeforeAdvice，ThrowingAdvice没有这样的子接口。这是因为用户可能需要同时对多种异常进行处理，如果把接口方法定义好了，那用户只能在方法体中判断当前捕获的异常类型了。没有方法定义时用户就可以在实现类中定义很多的异常处理方法了，但是这些方法也不是随便定义的，它们必须满足以下形式。其中的方法名必须为afterThrowing，方法参数只有最后一个subclassOfThrowable是必须的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afterThrowing([Method, args, target], subclassOfThrowable)</span><br></pre></td></tr></table></figure>

<p>以下是一个实现示例，在示例中我们一共实现了三个处理Exception的方法，前两个处理方法用于处理特定的异常类型，而且只接收一个异常类型参数，最后一个处理方法接收所有的参数，处理除前两者以外的其它异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogThrowsAdvice</span> <span class="keyword">implements</span> <span class="title">ThrowsAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 处理IllegalArgumentException</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(IllegalArgumentException e)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"=====================方法调用异常，抛出了IllegalArgumentException"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 处理NumberFormatException</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(NumberFormatException e)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"=====================方法调用异常，抛出了NumberFormatException"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 处理其它所有的异常</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Method method, Object[] args, Object target, Exception e)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"=====================方法调用异常了，"</span> + e);</span><br><span class="line">		System.out.println(<span class="string">"Method: "</span> + method);</span><br><span class="line">		System.out.println(<span class="string">"Args: "</span> + args);</span><br><span class="line">		System.out.println(<span class="string">"Target: "</span> + target);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="after-Advice"><a href="#after-Advice" class="headerlink" title="after Advice"></a>after Advice</h2><p>对于After Advice类型的Advice没有特定的接口供我们实现，如果需要自己实现一个Advice可以达到after Advice那样的效果，即无论切入点方法是否抛出异常都执行某些逻辑时，可以使用MethodInterceptor代替，在方法实现中使用try…finally形式即可。</p>
<p>上面配置的完整配置如下。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"bean(userService)"</span> <span class="attr">id</span>=<span class="string">"userServicePointcut"</span>/&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"logBeforeAdvice"</span> <span class="attr">order</span>=<span class="string">"1"</span> <span class="attr">pointcut-ref</span>=<span class="string">"userServicePointcut"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"logThrowsAdvice"</span> <span class="attr">order</span>=<span class="string">"2"</span> <span class="attr">pointcut-ref</span>=<span class="string">"userServicePointcut"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"logAfterReturningAdvice"</span> <span class="attr">order</span>=<span class="string">"3"</span> <span class="attr">pointcut-ref</span>=<span class="string">"userServicePointcut"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"logAroundAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"userServicePointcut"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logBeforeAdvice"</span> <span class="attr">class</span>=<span class="string">"com.elim.spring.aop.advice.LogBeforeAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logThrowsAdvice"</span> <span class="attr">class</span>=<span class="string">"com.elim.spring.aop.advice.LogThrowsAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logAfterReturningAdvice"</span> <span class="attr">class</span>=<span class="string">"com.elim.spring.aop.advice.LogAfterReturningAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logAroundAdvice"</span> <span class="attr">class</span>=<span class="string">"com.elim.spring.aop.advice.LogAroundAdvice"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>（注：本文是基于Spring4.1.0，Elim写于2017年1月23日星期一）</p>
<h1 id="基于正则表达式的Pointcut"><a href="#基于正则表达式的Pointcut" class="headerlink" title="基于正则表达式的Pointcut"></a>基于正则表达式的Pointcut</h1><h2 id="JdkRegexpMethodPointcut"><a href="#JdkRegexpMethodPointcut" class="headerlink" title="JdkRegexpMethodPointcut"></a>JdkRegexpMethodPointcut</h2><p>Spring官方为我们提供了一个基于正则表达式来匹配方法名的Pointcut，<code>JdkRegexpMethodPointcut</code>。该Pointcut是继承自<code>StaticMethodMatcherPointcut</code>的。我们在定义<code>JdkRegexpMethodPointcut</code>时可以通过<code>patterns</code>和<code>excludedPatterns</code>来注入需要满足和排除的正则表达式，它们对应的都是一个<code>String[]</code>。比如我们想匹配所有的方法名以<code>find</code>开头的方法，我们可以如下定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"regexPointcut"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.JdkRegexpMethodPointcut"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"patterns"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>find.*<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!-- 所有方法名以find开始的方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果我们需要匹配或需要排除的正则表达式只是单一的一个正则表达式，那么我们也可以通过<code>pattern</code>和<code>excludedPattern</code>来指定单一的需要匹配和排除的正则表达式。需要注意的是<code>patterns</code>和<code>pattern</code>不能同时使用，<code>excludedPattern</code>和<code>excludedPatterns</code>也是一样的。当我们同时指定了<code>patterns</code>和<code>excludedPatterns</code>时，该<code>Pointcut</code>将先匹配<code>patterns</code>，对于能够匹配<code>patterns</code>的将再判断其是否在<code>excludedPatterns</code>中，如果存在也将不匹配。以下是该匹配逻辑的核心代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchesPattern</span><span class="params">(String signatureString)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.patterns.length; i++) &#123;</span><br><span class="line">		<span class="keyword">boolean</span> matched = matches(signatureString, i);</span><br><span class="line">		<span class="keyword">if</span> (matched) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.excludedPatterns.length; j++) &#123;</span><br><span class="line">				<span class="keyword">boolean</span> excluded = matchesExclusion(signatureString, j);</span><br><span class="line">				<span class="keyword">if</span> (excluded) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要说明的是在上面的匹配逻辑中传递的参数signatureString是对应方法的全路径名称，即包含该方法的类的全路径及该方法的名称，如“org.springframework.aop.support.JdkRegexpMethodPointcut.matches”这种，所以如果我们需要在使用正则表达式定义Pointcut时，也可以匹配某某类的某某方法这种形式。</p>
</blockquote>
<h2 id="RegexpMethodPointcutAdvisor"><a href="#RegexpMethodPointcutAdvisor" class="headerlink" title="RegexpMethodPointcutAdvisor"></a>RegexpMethodPointcutAdvisor</h2><p>使用了<code>JdkRegexpMethodPointcut</code>后，我们在使用的时候通常会进行如下配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"logBeforeAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"regexPointcut"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logBeforeAdvice"</span> <span class="attr">class</span>=<span class="string">"com.elim.learn.spring.aop.advice.LogBeforeAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"regexPointcut"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.JdkRegexpMethodPointcut"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"patterns"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>find.*<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!-- 所有方法名以find开始的方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其实针对于<code>JdkRegexpMethodPointcut</code>，Spring为我们提供了一个简便的<code>Advisor</code>定义，可以让我们同时指定一个<code>JdkRegexpMethodPointcut</code>和其需要对应的<code>Advice</code>，那就是<code>RegexpMethodPointcutAdvisor</code>，我们可以给它注入一个Advice和对应需要匹配的正则表达式（pattern或patterns注入）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.RegexpMethodPointcutAdvisor"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"logBeforeAdvice"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"find.*"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是<code>RegexpMethodPointcutAdvisor</code>没有提供不匹配的正则表达式注入方法，即没有excludedPattern和excludedPatterns注入，如果需要该功能请还是使用<code>JdkRegexpMethodPointcut</code>。</p>
</blockquote>
<p>（本文是基于Spring4.1.0所写，Elim写于2017年5月8日）</p>
<h1 id="编程式的Pointcut"><a href="#编程式的Pointcut" class="headerlink" title="编程式的Pointcut"></a>编程式的Pointcut</h1><p>除了可以通过注解和Xml配置定义Pointcut之外，其实我们还可以通过程序来定义<code>Pointcut</code>。Spring Aop的切入点（Pointcut）对应于它的一个<code>Pointcut</code>接口，全称是<code>org.springframework.aop.Pointcut</code>。该接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">ClassFilter <span class="title">getClassFilter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	Pointcut TRUE = TruePointcut.INSTANCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口一共定义了两个核心方法，一个用于获取该Pointcut对应的过滤Class的ClassFilter对象，一个用于获取过滤Method的MethodMatcher对象。<br>ClassFilter接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line"></span><br><span class="line">	ClassFilter TRUE = TrueClassFilter.INSTANCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口只定义了一个matches方法，用于判断指定的Class对象是否匹配当前的过滤规则。<br>MethodMatcher接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodMatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, Object[] args)</span></span>;</span><br><span class="line"></span><br><span class="line">	MethodMatcher TRUE = TrueMethodMatcher.INSTANCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口中一共定义了三个方法，两个matches方法，一个包含方法参数一个不包含。不包含方法参数的matches方法用于判断非运行时的方法匹配，比如只需要匹配方法名、方法参数定义的；包含方法参数值的matches方法用于运行时判断方法是否匹配，应用于需要根据方法传参来判断是否匹配的情况，但是该方法一般会在不包含方法参数的matches方法返回true和isRuntime()方法true的情形下才会调用。isRuntime()方法用于指定该Pointcut是否需要在运行时才能判断对应的方法是否匹配。</p>
<h2 id="自定义Pointcut"><a href="#自定义Pointcut" class="headerlink" title="自定义Pointcut"></a>自定义Pointcut</h2><p>以下是一个自定义Pointcut的代码，其将匹配所有的名称Service结尾的Class对应的名称以find开始的方法调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.ClassFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodMatcher;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义Pointcut</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Elim</span></span><br><span class="line"><span class="comment"> * 2017年5月8日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCustomPointcut</span> <span class="keyword">implements</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ClassFilter <span class="title">getClassFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyCustomClassFilter();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyCustomMethodMatcher();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCustomClassFilter</span> <span class="keyword">implements</span> <span class="title">ClassFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">			<span class="comment">//实现自己的判断逻辑，这里简单的判断对应Class的名称是以Service结尾的就表示匹配</span></span><br><span class="line">			<span class="keyword">return</span> clazz.getName().endsWith(<span class="string">"Service"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCustomMethodMatcher</span> <span class="keyword">implements</span> <span class="title">MethodMatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">			<span class="comment">//实现方法匹配逻辑</span></span><br><span class="line">			<span class="keyword">return</span> method.getName().startsWith(<span class="string">"find"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, Object[] args)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们可以定义该自定义Pointcut对应的bean，再定义一个Advisor将使用该Pointcut。如下示例中我们就指定了将在MyCustomPointcut对应的切入点处采用LogAroundAdvice。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"logAroundAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myCustomPointcut"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logAroundAdvice"</span> <span class="attr">class</span>=<span class="string">"com.elim.learn.spring.aop.advice.LogAroundAdvice"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myCustomPointcut"</span> <span class="attr">class</span>=<span class="string">"com.elim.learn.spring.aop.pointcut.MyCustomPointcut"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="继承自现有的Pointcut"><a href="#继承自现有的Pointcut" class="headerlink" title="继承自现有的Pointcut"></a>继承自现有的Pointcut</h2><p>除了可以完全实现Pointcut接口外，我们还可以直接使用Spring自带的Pointcut。比如基于固定方法的StaticMethodMatcherPointcut。该Pointcut是一个抽象类，在使用该Pointcut时只需要实现一个抽象方法matches(Method method, Class&lt;?&gt; targetClass)，以下是一个继承自StaticMethodMatcherPointcut的示例类定义，该Pointcut将匹配所有Class中定义的方法名以find开头的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMethodMatcherPointcut</span> <span class="keyword">extends</span> <span class="title">StaticMethodMatcherPointcut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> method.getName().startsWith(<span class="string">"find"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于更多Spring官方已经提供的其它Pointcut定义请参考Spring的API文档。</p>
<p>（注：本文是基于Spring4.1.0所写，Elim写于2017年5月8日）</p>
<h1 id="编程式的创建Aop代理之ProxyFactory"><a href="#编程式的创建Aop代理之ProxyFactory" class="headerlink" title="编程式的创建Aop代理之ProxyFactory"></a>编程式的创建Aop代理之ProxyFactory</h1><p>Spring Aop是基于代理的，ProxyFactory是Spring Aop内部用来创建Proxy对象的一个工厂类。如果我们需要在程序运行时来动态的应用Spring Aop，则我们可以考虑使用ProxyFactory。使用ProxyFactory时，我们需要为它指定我们需要代理的目标对象、代理时我们需要使用的Advisor或Advice。如下示例就是一个简单的使用ProxyFactory创建MyService对象的代理，同时对其应用了一个MethodBeforeAdvice，即每次调用代理对象的方法时都将先调用MethodBeforeAdvice的before方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProxyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyService myService = <span class="keyword">new</span> MyService();</span><br><span class="line">	ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory(myService);</span><br><span class="line">	proxyFactory.addAdvice(<span class="keyword">new</span> MethodBeforeAdvice() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"执行目标方法调用之前的逻辑"</span>);</span><br><span class="line">			<span class="comment">//不需要手动去调用目标方法，</span></span><br><span class="line">                               <span class="comment">//Spring内置逻辑里面会调用目标方法</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;);;</span><br><span class="line">	MyService proxy = (MyService) proxyFactory.getProxy();</span><br><span class="line">	proxy.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指定被代理对象"><a href="#指定被代理对象" class="headerlink" title="指定被代理对象"></a>指定被代理对象</h2><p>ProxyFactory有多个重载的构造函数，上面示例中笔者用的是指定被代理对象的构造函数，如果我们应用的是其它构造函数，则可以通过ProxyFactory的setTarget(Object)方法来指定被代理对象。如果我们没有指定被代理对象的Class，那么默认创建出来的代理对象是我们传递的被代理对象的类型，即获取的是targetObject.getClass()类型。如果我们的被代理对象的类型是包含多个接口实现或父类型的，而我们只希望代理其中的某一个类型时，我们可以通过ProxyFactory的setTargetClass(Class)来指定创建的代理对象是基于哪个Class的。默认情况下，ProxyFactory会根据实际情况选择创建的代理对象是基于JDK代理的还是基于CBLIB代理的，即目标对象拥有接口实现且没有设置<code>proxyTargetClass=&quot;true&quot;</code>或者指定的targetClass是一个接口的时候将采用JDK代理，否则将采用CGLIB代理。也就是说即算是你通过ProxyFactory.setProxyTargetClass(true)指定了将会建立基于Class的CGLIB代理，最终也不一定是CGLIB代理，因为这种情况下如果targetClass是一个接口也将建立JDK代理。这块的逻辑是由DefaultAopProxyFactory的createAopProxy()方法实现的，其源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass()</span><br><span class="line">                     || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">				</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">	<span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface()) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>ProxyFactory底层在创建代理对象的时候实际上是会委托给AopProxyFactory对象的，AopProxyFactory是一个接口，其只定义了一个createAopProxy()方法，Spring提供了一个默认实现，DefaultAopProxyFactory。ProxyFactory中使用的就是DefaultAopProxyFactory，有兴趣的朋友可以参考一下ProxyFactory的源代码。</p>
<h2 id="指定Advisor"><a href="#指定Advisor" class="headerlink" title="指定Advisor"></a>指定Advisor</h2><p>使用Aop时我们是需要对拦截的方法做一些处理的，对于Spring Aop来讲，需要对哪些方法调用做什么样的处理是通过Advisor来定义的，通常是一个PointcutAdvisor。PointcutAdvisor接口中包含主要有两个接口方法，一个用来获取Pointcut，一个用来获取Advice对象，它俩的组合就构成了需要在哪个Pointcut应用哪个Advice。所以有需要的时候我们也可以实现自己的Advisor实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单的实现自己的PointcutAdvisor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Elim 2017年5月9日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvisor</span> <span class="keyword">implements</span> <span class="title">PointcutAdvisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MethodBeforeAdvice() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, </span></span></span><br><span class="line"><span class="function"><span class="params">  </span></span></span><br><span class="line"><span class="function"><span class="params">                            Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">				</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"BeforeAdvice实现，在目标方法被调用前调用，目标方法是："</span> </span><br><span class="line"></span><br><span class="line">+ method.getDeclaringClass().getName() + <span class="string">"."</span></span><br><span class="line">						+ method.getName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Pointcut <span class="title">getPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//匹配所有的方法调用</span></span><br><span class="line">		<span class="keyword">return</span> Pointcut.TRUE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProxyFactory2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		MyService myService = <span class="keyword">new</span> MyService();</span><br><span class="line">		ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory(myService);</span><br><span class="line">		proxyFactory.addAdvisor(<span class="keyword">new</span> MyAdvisor());</span><br><span class="line">		MyService proxy = (MyService) proxyFactory.getProxy();</span><br><span class="line">		proxy.add();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例就是一个指定代理对象对应的Advisor的示例。其实一个代理对象可以同时绑定多个Advisor对象，ProxyFactory的addAdvisor()方法可多次被调用，且该方法还有一些重载的方法定义，可以参数Spring的API文档。</p>
<h2 id="指定Advice"><a href="#指定Advice" class="headerlink" title="指定Advice"></a>指定Advice</h2><p>我们的第一个示例指定的代理对象绑定的是一个Advice，而第二个示例指定的Advisor，对此你会不会有什么疑问呢？依据我们对Spring Aop的了解，Spring的Aop代理对象绑定的就一定是一个Advisor，而且通常是一个PointcutAdvisor，通过它我们可以知道我们的Advice究竟是要应用到哪个Pointcut（哪个方法调用）？当我们通过ProxyFactory在创建代理对象时绑定的是一个Advice对象时，实际上ProxyFactory内部还是为我们转换为了一个Advisor对象的，只是该Advisor对象对应的Pointcut是一个匹配所有方法调用的Pointcut实例。</p>
<h2 id="指定是否需要发布代理对象"><a href="#指定是否需要发布代理对象" class="headerlink" title="指定是否需要发布代理对象"></a>指定是否需要发布代理对象</h2><p>在调用Aop代理对象的方法时，默认情况下我们是不能访问到当前的代理对象的，如果我们指定了创建的代理对象需要对外发布代理对象，那么在调用代理对象的方法时Spring会把当前的代理对象存入AopContext中，我们就可以在目标对象的方法中通过AopContext中获取到当前的代理对象了。这是通过exposeProxy属性来指定的，如果我们希望对外发布代理对象，我们可以通过exposeProxy的set方法来指定该属性的值为true。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProxyFactory2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyService myService = <span class="keyword">new</span> MyService();</span><br><span class="line">	ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory(myService);</span><br><span class="line">	proxyFactory.setExposeProxy(<span class="keyword">true</span>);<span class="comment">//指定对外发布代理对象，即在目标对象方法中可以通过AopContext.currentProxy()访问当前代理对象。</span></span><br><span class="line">	proxyFactory.addAdvisor(<span class="keyword">new</span> MyAdvisor());</span><br><span class="line">	proxyFactory.addAdvisor(<span class="keyword">new</span> MyAdvisor());<span class="comment">//多次指定Advisor将同时应用多个Advisor</span></span><br><span class="line">	MyService proxy = (MyService) proxyFactory.getProxy();</span><br><span class="line">	proxy.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上述配置信息以外，ProxyFactory其实还可以配置很多其它的信息，更多的配置信息项请参考ProxyFactory的源代码或参考Spring API文档。</p>
<p><strong>参考文档</strong></p>
<ul>
<li>Spring4.1.0官方文档</li>
<li>Spring源代码</li>
</ul>
<p>（本文是基于Spring4.1.0所写，Elim写于2017年5月9日）</p>
<h1 id="编程式的创建Aop代理之AspectjProxyFactory"><a href="#编程式的创建Aop代理之AspectjProxyFactory" class="headerlink" title="编程式的创建Aop代理之AspectjProxyFactory"></a>编程式的创建Aop代理之AspectjProxyFactory</h1><p>之前已经介绍了一款编程式的创建Aop代理的工厂——<code>ProxyFactory</code>，其实<code>ProxyFactory</code>拥有的功能<code>AspectjProxyFactory</code>都有。它们虽然没有直接的继承关系，但是它们都继承自<code>ProxyCreatorSupport</code>，而创建代理对象的核心逻辑都是在<code>ProxyCreatorSupport</code>中实现的。所以说<code>ProxyFactory</code>拥有的功能<code>AspectjProxyFactory</code>都有。那么<code>AspectjProxyFactory</code>与<code>ProxyFactory</code>相比有什么不同呢？<br><code>AspectjProxyFactory</code>的特殊之处就在于其可以直接指定需要创建的代理对象需要绑定的切面。在使用P<code>roxyFactory</code>时，我们能够绑定的是<code>Advisor</code>或<code>Advice</code>，但是如果我们的程序中已经有了现成的切面类定义且能够为我们新创建的代理类使用时，我们还要为了<code>ProxyFactory</code>建立代理对象的需要创建对应的<code>Advisor</code>类、<code>Advice</code>类和<code>Pointcut</code>类定义，这无疑是非常麻烦的。<code>AspectjProxyFactory</code>通常用于创建基于Aspectj风格的Aop代理对象。现假设我们有如下这样一个切面类定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Pointcut</span>(<span class="string">"execution(* add(..))"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beforeAdd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Before</span>(<span class="string">"beforeAdd()"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"-----------before-----------"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述切面类定义中我们定义了一个<code>Advisor</code>，其对应了一个<code>BeforeAdvice</code>，实际上是一个<code>AspectJMethodBeforeAdvice</code>，该<code>Advice</code>对应的是上面的<code>before1()</code>方法，还对应了一个<code>Pointcut</code>，实际上是一个<code>AspectJExpressionPointcut</code>。该<code>Advisor</code>的语义就是调用所有的方法名为“add”的方法时都将在调用前调用<code>MyAspect.before1()</code>方法。如果我们现在需要创建一个代理对象，其需要绑定的<code>Advisor</code>逻辑跟上面定义的切面类中定义的<code>Advisor</code>类似。则我们可以进行如下编程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAspectJProxyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyService myService = <span class="keyword">new</span> MyService();</span><br><span class="line">	AspectJProxyFactory proxyFactory = <span class="keyword">new</span> AspectJProxyFactory(myService);</span><br><span class="line">	proxyFactory.addAspect(MyAspect<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);<span class="comment">//是否需要使用CGLIB代理</span></span><br><span class="line">	MyService proxy = proxyFactory.getProxy();</span><br><span class="line">	proxy.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中我们<code>AspectjProxyFactory</code>在创建代理对象时需要使用的切面类（其实addAspect还有一个重载的方法可以指定一个切面类的对象），其实在<code>AspectjProxyFactory</code>内部还是解析了该切面类中包含的所有的<code>Advisor</code>，然后把能够匹配当前代理对象类的<code>Advisor</code>与创建的代理对象绑定了。有兴趣的读者可以查看一下<code>AspectjProxyFactory</code>的源码，以下是部分核心代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAspect</span><span class="params">(Class&lt;?&gt; aspectClass)</span> </span>&#123;</span><br><span class="line">	String aspectName = aspectClass.getName();</span><br><span class="line">	AspectMetadata am = createAspectMetadata(aspectClass, aspectName);</span><br><span class="line">	MetadataAwareAspectInstanceFactory instanceFactory = </span><br><span class="line">            createAspectInstanceFactory(am, aspectClass, aspectName);</span><br><span class="line">	addAdvisorsFromAspectInstanceFactory(instanceFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addAdvisorsFromAspectInstanceFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    MetadataAwareAspectInstanceFactory instanceFactory)</span> </span>&#123;</span><br><span class="line">	List&lt;Advisor&gt; advisors = <span class="keyword">this</span>.aspectFactory.getAdvisors(instanceFactory);</span><br><span class="line">	advisors = AopUtils.findAdvisorsThatCanApply(advisors, getTargetClass());</span><br><span class="line">	AspectJProxyUtils.makeAdvisorChainAspectJCapableIfNecessary(advisors);</span><br><span class="line">	OrderComparator.sort(advisors);</span><br><span class="line">	addAdvisors(advisors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是在使用<code>AspectjProxyFactory</code>基于切面类创建代理对象时，我们指定的切面类上必须包含@Aspect注解。<br>另外需要注意的是虽然我们自己通过编程的方式可以通过<code>AspectjProxyFactory</code>创建基于<code>@Aspect</code>标注的切面类的代理，但是通过配置``使用基于注解的Aspectj风格的Aop时，Spring内部不是通过<code>AspectjProxyFactory</code>创建的代理对象，而是通过<code>ProxyFactory</code>。有兴趣的朋友可以查看一下<code>AnnotationAwareAspectjAutoProxyCreator</code>的源代码。</p>
</blockquote>
<p>（注：本文是基于Spring4.1.0所写，Elim写于2017年5月9日）</p>
<h1 id="ProxyFactoryBean创建代理对象"><a href="#ProxyFactoryBean创建代理对象" class="headerlink" title="ProxyFactoryBean创建代理对象"></a>ProxyFactoryBean创建代理对象</h1><p><code>ProxyFactoryBean</code>实现了Spring的<code>FactoryBean</code>接口，所以它跟Spring中的其它<code>FactoryBean</code>一样，都是基于工厂模式来获取一个bean的。<code>ProxyFactoryBean</code>就是用来获取一个对象的代理对象的<code>FactoryBean</code>。它也是继承自<code>ProxyCreatorSupport</code>类的，所以它的功能基本跟<code>ProxyFactory</code>差不多，只是<code>ProxyFactory</code>是用于编程式的创建代理对象。而<code>ProxyFactoryBean</code>用于在Spring的bean容器中创建基于bean的代理对象。通常一个简单的<code>ProxyFactoryBean</code>配置大概会是如下这样。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"proxyFactoryBeanTestService"</span> </span><br><span class="line">  <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span><br><span class="line">  &lt;property name=<span class="string">"target"</span>&gt;&lt;!-- 指定被代理的对象 --&gt;</span><br><span class="line">    &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.elim.learn.spring.aop.service.ProxyFactoryBeanTestService"</span>/&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property name=<span class="string">"proxyTargetClass"</span> value=<span class="string">"true"</span>/&gt;&lt;!-- 指定启用基于Class的代理 --&gt;</span><br><span class="line">  &lt;!-- 指定生成的代理对象需要绑定的Advice或Advisor在bean容器中的名称 --&gt;</span><br><span class="line">  &lt;property name=<span class="string">"interceptorNames"</span>&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">      &lt;value&gt;logAroundAdvice&lt;/value&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中我们被代理的对象对应的Class是<code>com.elim.learn.spring.aop.service.ProxyFactoryBeanTestService</code>，其是一个没有实现任何接口的Class，所以我们生成的代理对象最终会是基于CGLIB的代理。我们需要指定<code>proxyTargetClass=&quot;true&quot;</code>，以表示我们是倾向于使用CGLIB代理的，对于上面的配置实际上就是告诉Spring我们要使用CGLIB代理。虽然这里我们不指定<code>proxyTargetClass=&quot;true&quot;</code>时，Spring可能也会给我们使用CGLIB代理，为什么这里说是可能呢？因为<code>ProxyFactoryBean</code>默认生成的bean都是单例、且在生成bean时会自动检测被代理对象实现的接口，而且<code>proxyTargetClass</code>默认是false，这种情况下<code>ProxyFactoryBean</code>就会自动检测被代理对象的实现的接口。按理来说我们的bean是一个没有实现接口的bean，Spring给我们去找它实现的接口是找不出来的，但是我们知道Spring的Aop是会自动为我们的对象实现一些接口的。简单的说如果我们的bean容器中配置了其它的Advisor，那么我们指定的target对象有可能就不是一个原始的bean，而是一个已经被Aop代理过的bean对象，这种bean对象，Spring Aop默认会为其实现一个<code>Advised</code>接口。所以使用<code>ProxyFactoryBean</code>时，如果我们的代理对象类是没有实现接口的，或者我们期望生成代理对象时是基于Class的，而不是基于Interface的，我们最好明确的指定<code>proxyTargetClass=&quot;true&quot;</code>，而不是寄希望于Spring的自动决定机制。 指定被代理对象时，除了可以直接指定target外，我们还可以通过targetName指定被代理对象在bean容器中的bean名称。 在上面的示例中我们通过interceptorNames属性指定了生成的代理对象需要应用的Advisor/Advice对应于bean容器中的bean的名称。跟ProxyFactory一样，如果我们指定的是Advice对象，则其会转换为一个匹配所有方法调用的Advisor与代理对象绑定。 在指定intercepterNames时我们也可以通过“<em>”指定所有beanName以XX开始的Advisor/Advice，如我们的bean容器中同时拥有“abc1Advisor”、“abc2Advisor”两个Advisor，我们期望创建的ProxyFactoryBean同时应用这两个Advisor，那我们可以不用单独指定两次，而是一次性把interceptorNames指定的一个beanName为“abc</em>”。需要注意的是“*”只能定义在beanName的末端。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyFactoryBeanTestService"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span><span class="comment">&lt;!-- 指定被代理的对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">" com.elim.learn.spring.aop.service.ProxyFactoryBeanTestService"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyTargetClass"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span><span class="comment">&lt;!-- 指定启用基于Class的代理 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 指定生成的代理对象需要绑定的Advice或Advisor在bean容器中的名称 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>abc*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>其它配置信息</strong></p>
<ul>
<li><strong>exposeProxy</strong>：属于从<code>ProxyCreatorSupport</code>继承过来的属性，用于定义是否需要在调用代理对象时把代理对象发布到<code>AopContext</code>，默认是<code>false</code>。</li>
<li><strong>singleton</strong>：用来指定<code>ProxyFactoryBean</code>生成的bean是否是单例的，默认是<code>true</code>。该值对应于<code>FactoryBean</code>的isSingleton()接口方法的返回值。</li>
<li><strong>frozen</strong>：属于从<code>ProxyCreatorSupport</code>继承过来的属性，用于指定代理对象被创建后是否还允许更改代理配置，通过<code>Advised</code>接口更改。<code>true</code>表示不允许，默认是false。</li>
<li><strong>autodetectInterfaces</strong>：表示是否在生成代理对象时需要启用自动检测被代理对象实现的接口，默认是<code>true</code>。</li>
<li><strong>proxyInterfaces</strong>：基于接口的代理时指定需要代理的接口。</li>
<li><strong>interfaces</strong>：基于接口的代理时指定需要代理的接口，属于从<code>ProxyCreatorSupport</code>继承过来的。 关于<code>ProxyFactoryBean</code>的更多配置项信息可以参考Spring的API文档或<code>ProxyFactoryBean</code>的源代码。<br>（注：本文是基于Spring4.1.0所写，Elim写于2017年5月10日）</li>
</ul>
<h1 id="Aop自动创建代理对象的原理"><a href="#Aop自动创建代理对象的原理" class="headerlink" title="Aop自动创建代理对象的原理"></a>Aop自动创建代理对象的原理</h1><p>我们在使用Spring Aop时，通常Spring会自动为我们创建目标bean的代理对象，以使用对应的Advisor。<strong>前提是我们在使用Spring Aop时是使用的<code>&lt;aop:config/&gt;</code>或<code>&lt;aop:aspectj-autoproxy/&gt;</code></strong>，这是因为当我们在applicationContext.xml文件中通过<a href="aop:config/">aop:config/</a>的形式定义需要使用Aop的场景时，Spring会自动为我们添加<code>AspectjAwareAdvisorAutoProxyCreator</code>类型的bean；而我们定义了<code>&lt;aop:aspectj-autoproxy/&gt;</code>时，Spring会默认为我们添加<code>AnnotationAwareAspectjAutoProxyCreator</code>类型的bean。</p>
<p>Spring中在bean实例化后能够对bean对象进行包装的是<code>BeanPostProcessor</code>，<code>AspectjAwareAdvisorAutoProxyCreator</code>和<code>AnnotationAwareAspectjAutoProxyCreator</code>都是实现了<code>BeanPostProcessor</code>接口的。</p>
<p><code>AnnotationAwareAspectjAutoProxyCreator</code>的父类是<code>AspectjAwareAdvisorAutoProxyCreator</code></p>
<p>而<code>AspectjAwareAdvisorAutoProxyCreator</code>的父类是AbstractAdvisorAutoProxyCreator，<code>AbstractAdvisorAutoProxyCreator</code>的父类是实现了<code>BeanPostProcessor</code>的<code>AbstractAutoProxyCreator</code>。</p>
<p>它们的核心逻辑都是在bean初始化后找出bean容器中所有的能够匹配当前bean的Advisor，找到了则将找到的Advisor通过ProxyFactory创建该bean的代理对象返回。</p>
<p><code>AspectjAwareAdvisorAutoProxyCreator</code>在寻找候选的Advisor时会找到bean容器中所有的实现了Advisor接口的bean，而<code>AnnotationAwareAspectjAutoProxyCreator</code>则在<code>AspectjAwareAdvisorAutoProxyCreator</code>的基础上增加了对标注了<code>@Aspect</code>的bean的处理，会附加上通过<code>@Aspect</code>标注的bean中隐式定义的Advisor。所以这也是为什么我们在使用<code>@Aspect</code>标注形式的Spring Aop时需要在<code>applicationContext.xml</code>文件中添加<code>&lt;aop:aspectj-autoproxy/&gt;</code>的原因。</p>
<p>既然<code>AspectjAwareAdvisorAutoProxyCreator</code>和<code>AnnotationAwareAspectjAutoProxyCreator</code>都会自动扫描bean容器中的Advisor，所以当我们使用了<code>&lt;aop:config/&gt;</code>或<code>&lt;aop:aspectj-autoproxy/&gt;</code>形式的Aop定义时，<strong>如果因为某些原因光通过配置满足不了你Aop的需求，而需要自己实现Advisor接口时（一般是实现PointcutAdvisor接口），那这时候你只需要把自己的Advisor实现类，定义为Spring的一个bean即可</strong>。</p>
<p>如果你在<code>applicationContext.xml</code>中没有定义<a href="aop:config/">aop:config/</a>或<a href="aop:aspectj-autoproxy/">aop:aspectj-autoproxy/</a>，那你也可以直接在<code>applicationContext.xml</code>中直接定义<code>AspectjAwareAdvisorAutoProxyCreator</code>或<code>AnnotationAwareAspectjAutoProxyCreator</code>类型的bean，效果也是一样的。</p>
<p>其实为了能够在创建目标bean的时候能够自动创建基于我们自定义的Advisor实现类的代理对象，我们的bean容器中只要有<code>AbstractAutoProxyCreator</code>类型的bean定义即可，当然了你实现自己的<code>BeanPostProcessor</code>，在其<code>postProcessAfterInitialization</code>方法中创建自己的代理对象也是可以的。但是本着不重复发明轮子的原则，我们尽量使用官方已经提供好的实现即可。<code>AbstractAutoProxyCreator</code>是继承自<code>ProxyConfig</code>的，所以我们在定义<code>AbstractAutoProxyCreator</code>子类的bean时，我们也可以手动的定义一些<code>ProxyConfig</code>中包含的属性，比如<code>proxyTargetClass</code>、<code>exposeProxy</code>等。<code>AbstractAutoProxyCreator</code>的子类除了<code>AspectjAwareAdvisorAutoProxyCreator</code>和<code>AnnotationAwareAspectjAutoProxyCreator</code>外，我们可用的还有<code>BeanNameAutoProxyCreator</code>和<code>DefaultAdvisorAutoProxyCreator</code>。</p>
<h2 id="BeanNameAutoProxyCreator"><a href="#BeanNameAutoProxyCreator" class="headerlink" title="BeanNameAutoProxyCreator"></a>BeanNameAutoProxyCreator</h2><p><code>BeanNameAutoProxyCreator</code>可以用来定义哪些bean可与哪些<code>Advisor/Advice</code>绑定，以生成对应的代理对象。需要绑定的bean是通过<code>beanNames</code>属性来指定的，对应的是bean的名称，其中可以包含“<em>”号，表示任意字符，比如“abc</em>”则匹配任意名称以“abc”开始的bean；需要绑定的<code>Advisor/Advice</code>是通过<code>interceptorNames</code>来指定的，如果指定的是<code>Advisor</code>，那么是否可生成基于该<code>Advisor</code>的代理需要对应的bean能够匹配对应<code>Advisor</code>（<code>PointcutAdvisor</code>类型）的<code>Pointcut</code>；如果指定的是<code>Advice</code>，则该<code>Advice</code>会被包含在<code>Pointcut</code>恒匹配的<code>Advisor</code>中，即能够与所有的bean绑定生成对应的代理，且会对所有的方法调用起作用。 指定interceptorNames时是不能使用通配符的，只能精确的指定需要应用的<code>Advisor/Advice</code>对应的bean名称。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.elim.learn.spring.aop.service.UserServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myService"</span> <span class="attr">class</span>=<span class="string">"com.elim.learn.spring.aop.service.MyService"</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 匹配userService和所有名称以my开头的bean --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanNames"</span> <span class="attr">value</span>=<span class="string">"userService, my*"</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- interceptorNames中不能使用通配符，只能是精确匹配，</span></span><br><span class="line"><span class="comment">             即精确指定Advisor/Advice的bean名称 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span> <span class="attr">value</span>=<span class="string">"logBeforeAdvice, myAdvisor "</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logBeforeAdvice"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.elim.learn.spring.aop.advice.LogBeforeAdvice"</span> /&gt;</span></span><br><span class="line">	 </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAdvisor"</span> <span class="attr">class</span>=<span class="string">"com.elim.learn.spring.aop.advisor.MyAdvisor"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上就是一个使用<code>BeanNameAutoProxyCreator</code>建立指定的bean基于指定的<code>Advisor/Advice</code>的代理对象的示例。示例中我们指定interceptorNames时特意应用了一个<code>Advisor</code>实现和一个<code>Advice</code>实现。<code>Advice</code>会应用于所有绑定的bean的所有方法调用，而<code>Advisor</code>只会应用于其中的Pointcut能够匹配的方法调用。这里的源码我就不提供了，有兴趣的朋友可以自己试试。</p>
<h2 id="DefaultAdvisorAutoProxyCreator"><a href="#DefaultAdvisorAutoProxyCreator" class="headerlink" title="DefaultAdvisorAutoProxyCreator"></a>DefaultAdvisorAutoProxyCreator</h2><p><code>DefaultAdvisorAutoProxyCreator</code>的父类也是<code>AbstractAdvisorAutoProxyCreator</code>。<code>DefaultAdvisorAutoProxyCreator</code>的作用是会默认将bean容器中所有的<code>Advisor</code>都取到，如果有能够匹配某一个bean的<code>Advisor</code>存在，则会基于能够匹配该bean的所有<code>Advisor</code>创建对应的代理对象。需要注意的是<code>DefaultAdvisorAutoProxyCreator</code>在创建bean的代理对象时是不会考虑<code>Advice</code>的，只是<code>Advisor</code>。如上面的示例中，如果我们希望所有的bean都能够自动的与匹配的<code>Advisor</code>进行绑定生成对应的代理对象，那么我们可以调整配置如下。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.elim.learn.spring.aop.service.UserServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myService"</span> <span class="attr">class</span>=<span class="string">"com.elim.learn.spring.aop.service.MyService"</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAdvisor"</span> <span class="attr">class</span>=<span class="string">"com.elim.learn.spring.aop.advisor.MyAdvisor"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>DefaultAdvisorAutoProxyCreator</code>时可能我们并不希望为所有的bean定义都自动应用bean容器中的所有<code>Advisor</code>，而只是希望自动创建基于部分<code>Advisor</code>的代理对象。这个时候如果我们期望应用自动代理的<code>Advisor</code>的bean定义的名称都是拥有固定的前缀时，则我们可以应用<code>DefaultAdvisorAutoProxyCreator</code>的<code>setAdvisorBeanNamePrefix(String)</code>指定需要应用的<code>Advisor</code>的bean名称的前缀，同时需要通过<code>setUsePrefix(boolean)</code>指定需要应用这种前缀匹配机制。如我们的bean容器中有两个<code>Advisor</code>定义，一个bean名称是“myAdvisor”，一个bean名称是“youAdvisor”，如果只期望自动创建基于bean名称以“my”开始的Advisor的代理，则可以进行如下配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usePrefix"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 匹配所有bean名称以my开始的Advisor --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advisorBeanNamePrefix"</span> <span class="attr">value</span>=<span class="string">"my"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（注：本文是基于Spring4.1.0所写，Elim写于2017年5月12日）</p>
<h1 id="Spring-Aop原理之Advised接口"><a href="#Spring-Aop原理之Advised接口" class="headerlink" title="Spring Aop原理之Advised接口"></a>Spring Aop原理之Advised接口</h1><p>通过之前我们介绍的<code>ProxyFactory</code>我们知道，Spring Aop是通过<code>ProxyFactory</code>来创建代理对象的。<code>ProxyFactory</code>在创建代理对象时会委托给<code>DefaultAopProxyFactory.createAopProxy(AdvisedSupport config)</code>，<code>DefaultAopProxyFactory</code>内部会分情况返回基于JDK的<code>JdkDynamicAopProxy</code>或基于CGLIB的<code>ObjenesisCglibAopProxy</code>，它俩都实现了Spring的<code>AopProxy</code>接口。<code>AopProxy</code>接口中只定义了一个方法，<code>getProxy()</code>方法，Spring Aop创建的代理对象也就是该接口方法的返回结果。</p>
<p>我们先来看一下基于JDK代理的<code>JdkDynamicAopProxy</code>的getProxy()的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getProxy(ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> </span><br><span class="line">                + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">	&#125;</span><br><span class="line">	Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils</span><br><span class="line">            .completeProxiedInterfaces(<span class="keyword">this</span>.advised);</span><br><span class="line">	findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">	<span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到它最终是通过JDK的<code>Proxy</code>来创建的代理，使用的<code>InvocationHandler</code>实现类是它本身，而使用的接口是<code>AopProxyUtils.completeProxiedInterfaces(this.advised)</code>的返回结果。而这个<code>this.advised</code>对象是<code>AdvisedSupport</code>类型，它是<code>ProxyFactory</code>的父类（间接通过<code>ProxyCreatorSupport</code>继承，<code>ProxyFactory</code>的直接父类是<code>ProxyCreatorSupport</code>，<code>ProxyCreatorSupport</code>的父类是<code>AdvisedSupport</code>），<code>AdvisedSupport</code>的父类是<code>ProxyConfig</code>，<code>ProxyConfig</code>中包含创建代理对象时的一些配置项信息。以下是<code>AopProxyUtils.completeProxiedInterfaces(this.advised)</code>的内部逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt;[] completeProxiedInterfaces(AdvisedSupport advised) &#123;</span><br><span class="line">	Class&lt;?&gt;[] specifiedInterfaces = advised.getProxiedInterfaces();</span><br><span class="line">	<span class="keyword">if</span> (specifiedInterfaces.length == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// No user-specified interfaces: </span></span><br><span class="line">                <span class="comment">//check whether target class is an interface.</span></span><br><span class="line">		Class&lt;?&gt; targetClass = advised.getTargetClass();</span><br><span class="line">		<span class="keyword">if</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass.isInterface()) &#123;</span><br><span class="line">			specifiedInterfaces = <span class="keyword">new</span> Class&lt;?&gt;[] &#123;targetClass&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">boolean</span> addSpringProxy = !advised.isInterfaceProxied(SpringProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="keyword">boolean</span> addAdvised = !advised.isOpaque() </span><br><span class="line">                &amp;&amp; !advised.isInterfaceProxied(Advised<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="keyword">int</span> nonUserIfcCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (addSpringProxy) &#123;</span><br><span class="line">		nonUserIfcCount++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (addAdvised) &#123;</span><br><span class="line">		nonUserIfcCount++;</span><br><span class="line">	&#125;</span><br><span class="line">	Class&lt;?&gt;[] proxiedInterfaces = <span class="keyword">new</span> Class&lt;?&gt;[specifiedInterfaces.length</span><br><span class="line">                 + nonUserIfcCount];</span><br><span class="line">	System.arraycopy(specifiedInterfaces, <span class="number">0</span>, </span><br><span class="line">                proxiedInterfaces, <span class="number">0</span>, specifiedInterfaces.length);</span><br><span class="line">	<span class="keyword">if</span> (addSpringProxy) &#123;</span><br><span class="line">		proxiedInterfaces[specifiedInterfaces.length]</span><br><span class="line">                     = SpringProxy<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (addAdvised) &#123;</span><br><span class="line">		proxiedInterfaces[proxiedInterfaces.length - <span class="number">1</span>] = Advised<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> proxiedInterfaces;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到其会在<code>!advised.isOpaque() &amp;&amp; !advised.isInterfaceProxied(Advised.class)</code>返回<code>true</code>的情况下加上本文的主角<code>Advised</code>接口。<code>isOpaque()</code>是<code>ProxyConfig</code>中的一个方法，对应的是<code>opaque</code>属性，表示是否禁止将代理对象转换为<code>Advised</code>对象，默认是<code>false</code>。<code>!advised.isInterfaceProxied(Advised.class)</code>表示将要代理的目标对象类没有实现<code>Advised</code>接口，对于我们自己应用的<code>Class</code>来说，一般都不会自己去实现<code>Advised</code>接口的，所以这个通常也是返回<code>true</code>，所以通常创建Aop代理对象时是会创建包含<code>Advised</code>接口的代理对象的，即上述的<code>proxiedInterfaces[proxiedInterfaces.length - 1] = Advised.class</code>会被执行。<br>前面我们已经提到，<code>JdkDynamicAopProxy</code>创建代理对象应用的<code>InvocationHandler</code>是其自身，所以我们在调用<code>JdkDynamicAopProxy</code>创建的代理对象的任何方法时都将调用<code>JdkDynamicAopProxy</code>实现的<code>InvocationHandler</code>接口的<code>invoke(Object proxy, Method method, Object[] args)</code>方法。该方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	MethodInvocation invocation;</span><br><span class="line">	Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">	Class&lt;?&gt; targetClass = <span class="keyword">null</span>;</span><br><span class="line">	Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">			<span class="comment">// The target does not implement </span></span><br><span class="line">                        <span class="comment">// the equals(Object) method itself.</span></span><br><span class="line">			<span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">			<span class="comment">// The target does not implement the hashCode() </span></span><br><span class="line">                        <span class="comment">// method itself.</span></span><br><span class="line">			<span class="keyword">return</span> hashCode();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque </span><br><span class="line">                    &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">		method.getDeclaringClass().isAssignableFrom(Advised<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">			<span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line">			<span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(</span><br><span class="line">                                  <span class="keyword">this</span>.advised, method, args);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object retVal;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">			<span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">			oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">			setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// May be null. Get as late as possible to </span></span><br><span class="line">                <span class="comment">// minimize the time we "own" the target,</span></span><br><span class="line">		<span class="comment">// in case it comes from a pool.</span></span><br><span class="line">		target = targetSource.getTarget();</span><br><span class="line">		<span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">			targetClass = target.getClass();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get the interception chain for this method.</span></span><br><span class="line">		List&lt;Object&gt; chain = <span class="keyword">this</span>.advised</span><br><span class="line">                .getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check whether we have any advice. If we don't, </span></span><br><span class="line">                <span class="comment">// we can fallback on direct</span></span><br><span class="line">		<span class="comment">// reflective invocation of the target, </span></span><br><span class="line">                <span class="comment">// and avoid creating a MethodInvocation.</span></span><br><span class="line">		<span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// We can skip creating a MethodInvocation: </span></span><br><span class="line">                        <span class="comment">//just invoke the target directly</span></span><br><span class="line">			<span class="comment">// Note that the final invoker must be an </span></span><br><span class="line">                        <span class="comment">// InvokerInterceptor so we know it does</span></span><br><span class="line">			<span class="comment">// nothing but a reflective operation on the target, </span></span><br><span class="line">                        <span class="comment">// and no hot swapping or fancy proxying.</span></span><br><span class="line">			retVal = AopUtils.invokeJoinpointUsingReflection(target, </span><br><span class="line">                                     method, args);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// We need to create a method invocation...</span></span><br><span class="line">			invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, </span><br><span class="line">                               target, method, args, targetClass, chain);</span><br><span class="line">			<span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">			retVal = invocation.proceed();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Massage return value if necessary.</span></span><br><span class="line">		Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">		<span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp; </span><br><span class="line">                                returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">				!RawTargetAccess<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">                                .<span class="title">isAssignableFrom</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">			<span class="comment">// Special case: it returned "this" and </span></span><br><span class="line">                        <span class="comment">// the return type of the method</span></span><br><span class="line">			<span class="comment">// is type-compatible. Note that we can't help </span></span><br><span class="line">                        <span class="comment">// if the target sets</span></span><br><span class="line">			<span class="comment">// a reference to itself in another returned object.</span></span><br><span class="line">			retVal = proxy;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE </span><br><span class="line">                        &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line">	<span class="string">"Null return value from advice does not match primitive return type for: "</span> </span><br><span class="line">                + method);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">			<span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">			targetSource.releaseTarget(target);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">			<span class="comment">// Restore old proxy.</span></span><br><span class="line">			AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中关于<code>Advised</code>接口方法调用最核心的一句是如下这句。我们可以看到，当我们调用的目标方法是定义自<code>Advised</code>接口时，对应方法的调用将委托给<code>AopUtils.invokeJoinpointUsingReflection(this.advised, method, args)</code>，<code>invokeJoinpointUsingReflection</code>方法的逻辑比较简单，是通过Java反射来调用目标方法。在这里<code>invokeJoinpointUsingReflection</code>传递的目标对象正是<code>AdvisedSupport</code>类型的<code>this.advised</code>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">		method.getDeclaringClass().isAssignableFrom(Advised<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">	<span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line">	<span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AdvisedSupport</code>类是实现了<code>Advised</code>接口的，所以Spring Aop创建了基于<code>Advised</code>接口的代理对象后在调用<code>Advised</code>接口方法时可以把它委托给<code>AdvisedSupport</code>。而我们知道Spring Aop代理对象的创建正是基于<code>AdvisedSupport</code>的配置进行的（配置项主要都定义在<code>AdvisedSupport</code>的父类<code>ProxyConfig</code>类中）。创建代理对象时应用<code>AdvisedSupport</code>，调用<code>Advised</code>接口方法也用同一个实现了<code>Advised</code>接口的<code>AdvisedSupport</code>对象，所以这个过程在Spring Aop内部就可以很好的衔接。接着我们来看一下<code>Advised</code>接口的定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Advised</span> <span class="keyword">extends</span> <span class="title">TargetClassAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isFrozen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isProxyTargetClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	Class&lt;?&gt;[] getProxiedInterfaces();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isInterfaceProxied</span><span class="params">(Class&lt;?&gt; intf)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setTargetSource</span><span class="params">(TargetSource targetSource)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">TargetSource <span class="title">getTargetSource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setExposeProxy</span><span class="params">(<span class="keyword">boolean</span> exposeProxy)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isExposeProxy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setPreFiltered</span><span class="params">(<span class="keyword">boolean</span> preFiltered)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPreFiltered</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	Advisor[] getAdvisors();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addAdvisor</span><span class="params">(Advisor advisor)</span> <span class="keyword">throws</span> AopConfigException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addAdvisor</span><span class="params">(<span class="keyword">int</span> pos, Advisor advisor)</span> <span class="keyword">throws</span> AopConfigException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">removeAdvisor</span><span class="params">(Advisor advisor)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeAdvisor</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> AopConfigException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Advisor advisor)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">replaceAdvisor</span><span class="params">(Advisor a, Advisor b)</span> <span class="keyword">throws</span> AopConfigException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addAdvice</span><span class="params">(Advice advice)</span> <span class="keyword">throws</span> AopConfigException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addAdvice</span><span class="params">(<span class="keyword">int</span> pos, Advice advice)</span> <span class="keyword">throws</span> AopConfigException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">removeAdvice</span><span class="params">(Advice advice)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Advice advice)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">toProxyConfigString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Advised</code>接口中定义的方法还是非常多的，通过它我们可以在运行时了解我们的代理对象是基于CGLIB的还是基于JDK代理的；可以了解我们的代理对应应用了哪些<code>Advisor</code>；也可以在运行时给我们的代理对象添加和删除<code>Advisor/Advise</code>。本文旨在描述Spring Aop在创建代理对象时是如何基于<code>Advised</code>接口创建代理的，以及我们能够应用<code>Advised</code>接口做哪些事。文中应用的是Spring创建基于JDK代理对象的过程为示例讲解的，其实基于CGLIB的代理也是一样的。关于CGLIB的代理过程、本文中描述的一些核心类以及本文的核心——<code>Advised</code>接口的接口方法说明等请有兴趣的朋友参考Spring的API文档和相关的源代码。<br>（注：本文是基于Spring4.1.0所写，Elim写于2017年5月15日）</p>
<h1 id="编程式的自定义Advisor"><a href="#编程式的自定义Advisor" class="headerlink" title="编程式的自定义Advisor"></a>编程式的自定义Advisor</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>大多数情况下，我们的Aop应用都可以通过Spring的Aop配置来进行（不管是基于注解的，还是基于XML配置的）。Spring Aop的核心就是<code>Advisor</code>，<code>Advisor</code>接口中暂时有用的就是<code>getAdvice()</code>方法，而<code>isPerInstance()</code>方法官方说暂时还没有应用到，生成的<code>Advisor</code>是单例还是多例不由<code>isPerInstance()</code>的返回结果决定，而由自己在定义bean的时候控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Advisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Advice <span class="title">getAdvice</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPerInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在使用<code>Advisor</code>时不会直接实现<code>Advisor</code>的接口，而是实现<code>Advisor</code>接口的子接口，<code>PointcutAdvisor</code>或<code>IntroductionAdvisor</code>。<code>IntroductionAdvisor</code>个人感觉用处不大，我们之前介绍的<code>@DeclareParents</code>和``就属于<code>IntroductionAdvisor</code>使用，它们对应的是<code>DeclareParentsAdvisor</code>。剩下的大部分应用的都是<code>PointcutAdvisor</code>。<code>PointcutAdvisor</code>接口的定义如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PointcutAdvisor</span> <span class="keyword">extends</span> <span class="title">Advisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Pointcut <span class="title">getPointcut</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到它在<code>Advisor接口</code>的基础上新增了一个<code>getPointcut()</code>方法，用以指定我们的Advisor需要应用到哪些<code>Pointcut</code>，即哪些方法调用。编程式的<code>Pointcut</code>定义之前已经介绍过了，它不属于本文介绍的范畴，这里就不再赘述了，对这块不是很了解的读者建议从头看起，笔者的博文是系列博文，当然了也可以暂时先略过，直接看笔者下文的示例。</p>
<h2 id="实现自定义的Advisor"><a href="#实现自定义的Advisor" class="headerlink" title="实现自定义的Advisor"></a>实现自定义的<code>Advisor</code></h2><p>以下是笔者实现的一个自定义的<code>Advisor</code>，是实现的<code>PointcutAdvisor</code>接口。应用的<code>Advice</code>是<code>MethodBeforeAdvice</code>的实现；应用的<code>Pointcut</code>简单匹配所有类的方法名为<code>find</code>的方法调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvisor</span> <span class="keyword">implements</span> <span class="title">PointcutAdvisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MethodBeforeAdvice() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, </span></span></span><br><span class="line"><span class="function"><span class="params">                             Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"BeforeAdvice实现，在目标方法被调用前调用，目标方法是："</span> </span><br><span class="line">+ method.getDeclaringClass().getName() + <span class="string">"."</span></span><br><span class="line">						+ method.getName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Pointcut <span class="title">getPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 简单的Pointcut定义，匹配所有类的find方法调用。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Pointcut() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> ClassFilter <span class="title">getClassFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> ClassFilter.TRUE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> MethodMatcher() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">			String methodName = method.getName();</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">"find"</span>.equals(methodName)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Object[] args)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置使用自定义的Advisor"><a href="#配置使用自定义的Advisor" class="headerlink" title="配置使用自定义的Advisor"></a>配置使用自定义的<code>Advisor</code></h2><p>有了自定义的<code>Advisor</code>后我们应该如何来应用它呢？这又区分好几种情况。</p>
<ul>
<li>如果是自己通过编程应用<code>ProxyFactory</code>，或者说是应用<code>ProxyCreatorSupport</code>来创建代理对象，那么我们通过<code>AdvisedSupport.addAdvisor(Advisor advisor)</code>来应用我们自定义的<code>Advisor</code>。<code>AdvisedSupport</code>的子类中有<code>ProxyCreatorSupport</code>。</li>
<li>如果我们的项目中已经应用了<code>或</code>，那么我们定义在bean容器中的<code>Advisor</code> bean会自动应用到匹配的bean上。这个在<code>《Spring Aop原理之自动创建代理对象》</code>一文中有详细介绍。</li>
<li>如果项目中没有应用<code>或</code>，我们就需要自己定义<code>BeanNameAutoProxyCreator</code>、<code>DefaultAdvisorAutoProxyCreator</code>等<code>AbstractAdvisorAutoProxyCreator</code>类型的bean了。或者是定义<code>AnnotationAwareAspectjAutoProxyCreator</code>或<code>AspectJAwareAdvisorAutoProxyCreator</code>类型的bean，其实<code>就是自动定义了`AnnotationAwareAspectjAutoProxyCreator`类型的bean，</code>就是自动定义了<code>AspectJAwareAdvisorAutoProxyCreator</code>类型的bean。这样在创建bean后都会寻找匹配的<code>Advisor</code>建立对应的代理对象。这些都在<code>《Spring Aop原理之自动创建代理对象》</code>一文中有详细介绍，细节这里就不再赘述。</li>
</ul>
<p>（注：本文是基于Spring4.1.0所写，写于2017年5月16日）</p>

    </div>



<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>


  
</div>




    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Brooks.H.Joshua
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://52zhongneng.cn/2020/09/28/SpringBoot-Chapter3-AOP/" title="SpringBoot_Chapter3_AOP">https://52zhongneng.cn/2020/09/28/SpringBoot-Chapter3-AOP/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring-Boot/" rel="tag"><i class="fa fa-tag"></i>Spring-Boot</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/22/SpringBoot-Chapter4/" rel="prev" title="SpringBoot_Chapter4">
      <i class="fa fa-chevron-left"></i> SpringBoot_Chapter4
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/28/Algorithms/" rel="next" title="Algorithms">
      Algorithms <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
 


 <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Aop简介"><span class="nav-number">1.</span> <span class="nav-text">Aop简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本原理"><span class="nav-number">1.1.</span> <span class="nav-text">基本原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本概念"><span class="nav-number">1.2.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Advice类型"><span class="nav-number">1.2.1.</span> <span class="nav-text">Advice类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基于Aspectj注解的Spring-Aop简单实现"><span class="nav-number">2.</span> <span class="nav-text">基于Aspectj注解的Spring Aop简单实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#启用对Aspectj注解的支持"><span class="nav-number">2.1.</span> <span class="nav-text">启用对Aspectj注解的支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义切面类"><span class="nav-number">2.2.</span> <span class="nav-text">定义切面类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义Pointcut"><span class="nav-number">2.3.</span> <span class="nav-text">定义Pointcut</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义Advice"><span class="nav-number">2.4.</span> <span class="nav-text">定义Advice</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pointcut表达式介绍"><span class="nav-number">3.</span> <span class="nav-text">Pointcut表达式介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#表达式类型"><span class="nav-number">3.1.</span> <span class="nav-text">表达式类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用示例"><span class="nav-number">3.2.</span> <span class="nav-text">使用示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#execution"><span class="nav-number">3.2.1.</span> <span class="nav-text">execution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#within"><span class="nav-number">3.2.2.</span> <span class="nav-text">within</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this"><span class="nav-number">3.2.3.</span> <span class="nav-text">this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#target"><span class="nav-number">3.2.4.</span> <span class="nav-text">target</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#args"><span class="nav-number">3.2.5.</span> <span class="nav-text">args</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#target-1"><span class="nav-number">3.2.6.</span> <span class="nav-text">@target</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#args-1"><span class="nav-number">3.2.7.</span> <span class="nav-text">@args</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#within-1"><span class="nav-number">3.2.8.</span> <span class="nav-text">@within</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#annotation"><span class="nav-number">3.2.9.</span> <span class="nav-text">@annotation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bean"><span class="nav-number">3.2.10.</span> <span class="nav-text">bean</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表达式组合"><span class="nav-number">3.3.</span> <span class="nav-text">表达式组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于Aspectj注解的Pointcut表达式应用"><span class="nav-number">3.4.</span> <span class="nav-text">基于Aspectj注解的Pointcut表达式应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基于Aspectj注解的Advice介绍"><span class="nav-number">4.</span> <span class="nav-text">基于Aspectj注解的Advice介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Before"><span class="nav-number">4.1.</span> <span class="nav-text">@Before</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AfterReturning"><span class="nav-number">4.2.</span> <span class="nav-text">@AfterReturning</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AfterThrowing"><span class="nav-number">4.3.</span> <span class="nav-text">@AfterThrowing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#After"><span class="nav-number">4.4.</span> <span class="nav-text">@After</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Around"><span class="nav-number">4.5.</span> <span class="nav-text">@Around</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Advice执行顺序"><span class="nav-number">4.6.</span> <span class="nav-text">Advice执行顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#给Advice传递参数"><span class="nav-number">5.</span> <span class="nav-text">给Advice传递参数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#获取切入点方法参数"><span class="nav-number">5.1.</span> <span class="nav-text">获取切入点方法参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#argNames参数"><span class="nav-number">5.2.</span> <span class="nav-text">argNames参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取this对象"><span class="nav-number">5.3.</span> <span class="nav-text">获取this对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#混合使用"><span class="nav-number">5.4.</span> <span class="nav-text">混合使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取target对象"><span class="nav-number">5.5.</span> <span class="nav-text">获取target对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取注解对象"><span class="nav-number">5.6.</span> <span class="nav-text">获取注解对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型参数"><span class="nav-number">5.7.</span> <span class="nav-text">泛型参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DeclareParents介绍"><span class="nav-number">6.</span> <span class="nav-text">@DeclareParents介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基于XML配置的Spring-AOP"><span class="nav-number">7.</span> <span class="nav-text">基于XML配置的Spring AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#配置切面"><span class="nav-number">7.1.</span> <span class="nav-text">配置切面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置切入点"><span class="nav-number">7.2.</span> <span class="nav-text">配置切入点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置Advice"><span class="nav-number">7.3.</span> <span class="nav-text">配置Advice</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#declare-parents"><span class="nav-number">7.4.</span> <span class="nav-text">declare-parents</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启用CGLIB代理类"><span class="nav-number">7.5.</span> <span class="nav-text">启用CGLIB代理类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#advisor标签"><span class="nav-number">8.</span> <span class="nav-text">advisor标签</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#before-Advice"><span class="nav-number">8.1.</span> <span class="nav-text">before Advice</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#around-Advice"><span class="nav-number">8.2.</span> <span class="nav-text">around Advice</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#afterReturning-Advice"><span class="nav-number">8.3.</span> <span class="nav-text">afterReturning Advice</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#afterThrowing-Advice"><span class="nav-number">8.4.</span> <span class="nav-text">afterThrowing Advice</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#after-Advice"><span class="nav-number">8.5.</span> <span class="nav-text">after Advice</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基于正则表达式的Pointcut"><span class="nav-number">9.</span> <span class="nav-text">基于正则表达式的Pointcut</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JdkRegexpMethodPointcut"><span class="nav-number">9.1.</span> <span class="nav-text">JdkRegexpMethodPointcut</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RegexpMethodPointcutAdvisor"><span class="nav-number">9.2.</span> <span class="nav-text">RegexpMethodPointcutAdvisor</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编程式的Pointcut"><span class="nav-number">10.</span> <span class="nav-text">编程式的Pointcut</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义Pointcut"><span class="nav-number">10.1.</span> <span class="nav-text">自定义Pointcut</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承自现有的Pointcut"><span class="nav-number">10.2.</span> <span class="nav-text">继承自现有的Pointcut</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编程式的创建Aop代理之ProxyFactory"><span class="nav-number">11.</span> <span class="nav-text">编程式的创建Aop代理之ProxyFactory</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#指定被代理对象"><span class="nav-number">11.1.</span> <span class="nav-text">指定被代理对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指定Advisor"><span class="nav-number">11.2.</span> <span class="nav-text">指定Advisor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指定Advice"><span class="nav-number">11.3.</span> <span class="nav-text">指定Advice</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指定是否需要发布代理对象"><span class="nav-number">11.4.</span> <span class="nav-text">指定是否需要发布代理对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编程式的创建Aop代理之AspectjProxyFactory"><span class="nav-number">12.</span> <span class="nav-text">编程式的创建Aop代理之AspectjProxyFactory</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ProxyFactoryBean创建代理对象"><span class="nav-number">13.</span> <span class="nav-text">ProxyFactoryBean创建代理对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Aop自动创建代理对象的原理"><span class="nav-number">14.</span> <span class="nav-text">Aop自动创建代理对象的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanNameAutoProxyCreator"><span class="nav-number">14.1.</span> <span class="nav-text">BeanNameAutoProxyCreator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DefaultAdvisorAutoProxyCreator"><span class="nav-number">14.2.</span> <span class="nav-text">DefaultAdvisorAutoProxyCreator</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Aop原理之Advised接口"><span class="nav-number">15.</span> <span class="nav-text">Spring Aop原理之Advised接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编程式的自定义Advisor"><span class="nav-number">16.</span> <span class="nav-text">编程式的自定义Advisor</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">16.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现自定义的Advisor"><span class="nav-number">16.2.</span> <span class="nav-text">实现自定义的Advisor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置使用自定义的Advisor"><span class="nav-number">16.3.</span> <span class="nav-text">配置使用自定义的Advisor</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->



      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Brooks.H.Joshua"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Brooks.H.Joshua</p>
  <div class="site-description" itemprop="description">Less Is More</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://spring.io/blog" title="https:&#x2F;&#x2F;spring.io&#x2F;blog" rel="noopener" target="_blank">Spring官博</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://leetcode-cn.com/" title="https:&#x2F;&#x2F;leetcode-cn.com&#x2F;" rel="noopener" target="_blank">LeetCode</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.itboyhub.com/" title="http:&#x2F;&#x2F;www.itboyhub.com&#x2F;" rel="noopener" target="_blank">JavaBoy</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" title="https:&#x2F;&#x2F;www.cs.usfca.edu&#x2F;~galles&#x2F;visualization&#x2F;Algorithms.html" rel="noopener" target="_blank">DSV</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://visualgo.net/zh" title="https:&#x2F;&#x2F;visualgo.net&#x2F;zh" rel="noopener" target="_blank">DV</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.apache.org/index.html#projects-list" title="http:&#x2F;&#x2F;www.apache.org&#x2F;index.html#projects-list" rel="noopener" target="_blank">Apache</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://stackoverflow.com/" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;" rel="noopener" target="_blank">StackOverflow</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://metacademy.org/" title="https:&#x2F;&#x2F;metacademy.org&#x2F;" rel="noopener" target="_blank">Metacademy</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.alloyteam.com/nav/" title="http:&#x2F;&#x2F;www.alloyteam.com&#x2F;nav&#x2F;" rel="noopener" target="_blank">WebNav</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.36zhen.com/t?id=3448" title="http:&#x2F;&#x2F;www.36zhen.com&#x2F;t?id&#x3D;3448" rel="noopener" target="_blank">前端书籍资料</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://ife.baidu.com/" title="http:&#x2F;&#x2F;ife.baidu.com&#x2F;" rel="noopener" target="_blank">百度前端</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://wf.uisdc.com/cn/" title="http:&#x2F;&#x2F;wf.uisdc.com&#x2F;cn&#x2F;" rel="noopener" target="_blank">G前端开发基础</a>
        </li>
    </ul>
  </div>

     
	<!--网易云音乐-->
	  <div id="music163player">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1002994&auto=1&height=66"></iframe>
	  </div>
      </div>

    </div>
  </aside>

  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Brooks.H.Joshua</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">16:25</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

</html>
